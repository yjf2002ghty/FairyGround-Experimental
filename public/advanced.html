<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <title>Fairy-Stockfish Playground (Experimental)</title>
    <!-- By curl https://data-url-maker-hiro18181.netlify.app/api/url/https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg -->
    <link rel="icon"
          href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+CiAgPGcgc3R5bGU9Im9wYWNpdHk6MTsgZmlsbDpub25lOyBmaWxsLW9wYWNpdHk6MTsgZmlsbC1ydWxlOmV2ZW5vZGQ7IHN0cm9rZTojMDAwMDAwOyBzdHJva2Utd2lkdGg6MS41OyBzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDsgc3Ryb2tlLWRhc2hhcnJheTpub25lOyBzdHJva2Utb3BhY2l0eToxOyI+CiAgICA8cGF0aAogICAgICBkPSJNIDIyLDEwIEMgMzIuNSwxMSAzOC41LDE4IDM4LDM5IEwgMTUsMzkgQyAxNSwzMCAyNSwzMi41IDIzLDE4IgogICAgICBzdHlsZT0iZmlsbDojMDAwMDAwOyBzdHJva2U6IzAwMDAwMDsiIC8+CiAgICA8cGF0aAogICAgICBkPSJNIDI0LDE4IEMgMjQuMzgsMjAuOTEgMTguNDUsMjUuMzcgMTYsMjcgQyAxMywyOSAxMy4xOCwzMS4zNCAxMSwzMSBDIDkuOTU4LDMwLjA2IDEyLjQxLDI3Ljk2IDExLDI4IEMgMTAsMjggMTEuMTksMjkuMjMgMTAsMzAgQyA5LDMwIDUuOTk3LDMxIDYsMjYgQyA2LDI0IDEyLDE0IDEyLDE0IEMgMTIsMTQgMTMuODksMTIuMSAxNCwxMC41IEMgMTMuMjcsOS41MDYgMTMuNSw4LjUgMTMuNSw3LjUgQyAxNC41LDYuNSAxNi41LDEwIDE2LjUsMTAgTCAxOC41LDEwIEMgMTguNSwxMCAxOS4yOCw4LjAwOCAyMSw3IEMgMjIsNyAyMiwxMCAyMiwxMCIKICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDsgc3Ryb2tlOiMwMDAwMDA7IiAvPgogICAgPHBhdGgKICAgICAgZD0iTSA5LjUgMjUuNSBBIDAuNSAwLjUgMCAxIDEgOC41LDI1LjUgQSAwLjUgMC41IDAgMSAxIDkuNSAyNS41IHoiCiAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7IHN0cm9rZTojZmZmZmZmOyIgLz4KICAgIDxwYXRoCiAgICAgIGQ9Ik0gMTUgMTUuNSBBIDAuNSAxLjUgMCAxIDEgIDE0LDE1LjUgQSAwLjUgMS41IDAgMSAxICAxNSAxNS41IHoiCiAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuODY2LDAuNSwtMC41LDAuODY2LDkuNjkzLC01LjE3MykiCiAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7IHN0cm9rZTojZmZmZmZmOyIgLz4KICAgIDxwYXRoCiAgICAgIGQ9Ik0gMjQuNTUsMTAuNCBMIDI0LjEsMTEuODUgTCAyNC42LDEyIEMgMjcuNzUsMTMgMzAuMjUsMTQuNDkgMzIuNSwxOC43NSBDIDM0Ljc1LDIzLjAxIDM1Ljc1LDI5LjA2IDM1LjI1LDM5IEwgMzUuMiwzOS41IEwgMzcuNDUsMzkuNSBMIDM3LjUsMzkgQyAzOCwyOC45NCAzNi42MiwyMi4xNSAzNC4yNSwxNy42NiBDIDMxLjg4LDEzLjE3IDI4LjQ2LDExLjAyIDI1LjA2LDEwLjUgTCAyNC41NSwxMC40IHogIgogICAgICBzdHlsZT0iZmlsbDojZmZmZmZmOyBzdHJva2U6bm9uZTsiIC8+CiAgPC9nPgo8L3N2Zz4K" />
    <link rel="stylesheet" href="assets/chessground.css" />
    <link rel="stylesheet" href="assets/generated.css" />
    <link rel="stylesheet" href="assets/theme-backgrounds.css" />
    <link rel="stylesheet" href="assets/theme-default.css" />
    <base target="_blank">
</head>

<!-- CSS -->

<style>
    *,
    *::before,
    *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        border: 0;
        font: inherit;
    }

    html,
    body,
    #root {
        height: 100%;
    }

    #root {
        font-size: 16px;
    }

    main {
        height: 100%;
        display: flex;
        flex-direction: column;
        padding: 10px;
    }

    #pagetitle {
        font-size: 60px;
        font-family: 'Times New Roman', Times, serif, Arial;
        margin-bottom: 10px;
        font-style: oblique;
        font-weight: bold;
    }

    #input {
        display: flex;
        margin-bottom: 10px;
    }

    #input2 {
        display: flex;
        margin-bottom: 10px;
    }

    #ffishsettings {
        display: flex;
        margin-bottom: 10px;
    }

    #gamesettings {
        display: flex;
        margin-bottom: 10px;
    }

    #input #fen {
        width: 50%;
        padding: 2px 0 2px 6px;
        border: 1px solid #ddd;
        border-right: 0;
    }

    #input #move {
        width: 10%;
        padding: 2px 0 2px 6px;
        border: 1px solid #ddd;
        border-right: 0;
    }

    #ffishsettings #movetime {
        width: 10%;
        padding: 2px 0 2px 6px;
        border: 1px solid #ddd;
        border-right: 0;
    }

    #ffishsettings #depth {
        width: 10%;
        padding: 2px 0 2px 6px;
        border: 1px solid #ddd;
        border-right: 0;
    }

    #ffishsettings #nodes {
        width: 10%;
        padding: 2px 0 2px 6px;
        border: 1px solid #ddd;
        border-right: 0;
    }

    #ffishsettings #threads {
        width: 10%;
        padding: 2px 0 2px 6px;
        border: 1px solid #ddd;
        border-right: 0;
    }

    #ffishsettings #hash {
        width: 10%;
        padding: 2px 0 2px 6px;
        border: 1px solid #ddd;
        border-right: 0;
    }

    #ffishsettings #multipv {
        width: 10%;
        padding: 2px 0 2px 6px;
        border: 1px solid #ddd;
    }

    #input button {
        display: inline-block;
        padding: 3px 6px 3px 6px;
        background: #888;
        color: #fff;
        font-weight: bold;
        margin-right: 6px;
        cursor: pointer;
    }

    #input2 button {
        display: inline-block;
        padding: 3px 6px 3px 6px;
        background: #888;
        color: #fff;
        font-weight: bold;
        margin-right: 6px;
        cursor: pointer;
    }

    #movecontrol button {
        display: inline-block;
        padding: 3px 6px 3px 6px;
        background: #888;
        color: #fff;
        font-weight: bold;
        margin-right: 6px;
        margin-top: 2px;
        cursor: pointer;
    }

    #movecontrol #gotomovenum {
        width: 45%;
        padding: 2px 0 2px 6px;
        border: 1px solid #ddd;
        border-right: 0;
    }

    #controls button {
        display: inline-block;
        padding: 3px 6px 3px 6px;
        background: #888;
        color: #fff;
        font-weight: bold;
        margin-right: 6px;
        cursor: pointer;
    }

    #input #dropdown-variant {
        width: 120px;
        background: #eee;
    }

    #gamesettings #dropdown-quickpromotion {
        width: 120px;
        background: #eee;
        margin-left: 10px;
        margin-right: 10px;
    }

    #misc {
        margin-bottom: 10px;
    }

    #outputs {
        display: flex;
        flex: 1 1 auto;
        margin-top: 10px;
        width: 100%;
        height: 50%;
    }

    #movecontrol {
        margin-top: 20px;
        margin-bottom: 10px;
    }

    #posvariantdiv {
        display: flex;
        margin-bottom: 10px;
    }

        #posvariantdiv #dropdown-posvarianttype {
            min-width: 120px;
            background: #eee;
            margin-left: 10px;
        }

        #posvariantdiv #dropdown-posvariantname {
            min-width: 120px;
            background: #eee;
            margin-left: 10px;
        }

        #posvariantdiv button {
            display: inline-block;
            padding: 3px 6px 3px 6px;
            background: #888;
            color: #fff;
            font-weight: bold;
            margin-right: 6px;
            cursor: pointer;
        }

    #controls {
        margin-top: 20px;
        margin-bottom: 10px;
    }

    #info {
        padding: 10px;
        margin-left: 20px;
        font-size: 16px;
        height: 600px;
    }

        #info #timecontrolduringplay {
            padding: 10px;
            margin-left: 20px;
            font-size: 16px;
        }

            #info #timecontrolduringplay button {
                display: inline-block;
                padding: 3px 6px 3px 6px;
                background: #888;
                color: #fff;
                font-weight: bold;
                margin-right: 6px;
                cursor: pointer;
            }

    #currentboardfen {
        height: 10%;
        border: 1px solid #ddd;
        padding: 10px;
        margin-left: 20px;
        overflow-x: scroll;
        overflow-y: scroll;
        box-shadow: inset 1px 1px 2px #eee;
        font-size: 16px;
    }

    #label-pgn {
        height: 20%;
        border: 1px solid #ddd;
        padding: 10px;
        margin-left: 20px;
        overflow-x: scroll;
        overflow-y: scroll;
        box-shadow: inset 1px 1px 2px #eee;
        font-size: 16px;
    }

    #output2-div {
        height: 70%;
        border: 1px solid #ddd;
        padding: 10px;
        margin-left: 20px;
        overflow-x: scroll;
        overflow-y: scroll;
        box-shadow: inset 1px 1px 2px #eee;
        font-size: 16px;
    }

    #pocket-top {
        display: flex;
    }

    #pocket-bottom {
        display: flex;
    }

    #links a {
        margin: 20px;
        font-size: 20px;
        text-decoration: none;
    }

    #info #timers {
        width: 600px;
        height: 125px;
        border: 2px solid #EEE;
        background-color: gray;
        overflow: hidden;
    }

        #info #timers #whitetimer {
            float: left;
            width: 290px;
            height: 120px;
            border: 2px solid #000;
            color: black;
            background-color: white;
            text-align: center;
            overflow: hidden;
        }

        #info #timers #blacktimer {
            float: right;
            width: 290px;
            height: 120px;
            border: 2px solid #FFF;
            color: white;
            background-color: black;
            text-align: center;
            overflow: hidden;
        }

    #blacktime {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        font-size: 50px;
        font-weight: bold;
        font-family: "Times New Roman",Georgia,Serif,Arial;
    }

    #whitetime {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        font-size: 50px;
        font-weight: bold;
        font-family: "Times New Roman",Georgia,Serif,Arial;
    }

    #boardsetupsettings {
        margin-bottom: 10px;
    }

        #boardsetupsettings #boardpiecechange {
            display: flex;
            margin-bottom: 10px;
        }

            #boardsetupsettings #boardpiecechange #dropdown-setpiece {
                width: 120px;
                background: #eee;
            }

            #boardsetupsettings #boardpiecechange button {
                display: inline-block;
                padding: 3px 6px 3px 6px;
                background: #888;
                color: #fff;
                font-weight: bold;
                margin-right: 6px;
                cursor: pointer;
            }

    #boardsetupsettings2 {
        margin-top: 20px;
        margin-bottom: 10px;
     }

        #boardsetupsettings2 #dropdown-sidetomove {
            width: 120px;
            background: #eee;
        }

        #boardsetupsettings2 #halfmoveclock {
            width: 25%;
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
            border-right: 0;
        }

        #boardsetupsettings2 #whiteremainingchecks {
            width: 25%;
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
            border-right: 0;
        }

        #boardsetupsettings2 #blackremainingchecks {
            width: 25%;
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
            border-right: 0;
        }

        #boardsetupsettings2 #currentmovenum {
            width: 25%;
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
            border-right: 0;
        }

        #boardsetupsettings2 #enpassantfile {
            width: 35%;
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
            border-right: 0;
        }

        #boardsetupsettings2 #enpassantrank {
            width: 35%;
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
            border-right: 0;
        }

        #boardsetupsettings2 #seirwangatingfiles {
            width: 60%;
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
            border-right: 0;
        }

    #advancedtimesettings {
        margin-bottom: 10px;
    }

        #advancedtimesettings #whitetimesettings {
            display: flex;
            margin-bottom: 10px;
        }

            #advancedtimesettings #whitetimesettings #dropdown-whitetimemode {
                margin-left: 10px;
                width: 120px;
                background: #eee;
            }

            #advancedtimesettings #whitetimesettings #whitestarttime {
                width: 15%;
                padding: 2px 0 2px 6px;
                border: 1px solid #ddd;
                border-right: 0;
            }

            #advancedtimesettings #whitetimesettings #whitetimegain {
                width: 15%;
                padding: 2px 0 2px 6px;
                border: 1px solid #ddd;
                border-right: 0;
            }

            #advancedtimesettings #whitetimesettings #whitebyoyomitime {
                width: 15%;
                padding: 2px 0 2px 6px;
                border: 1px solid #ddd;
                border-right: 0;
            }

            #advancedtimesettings #whitetimesettings #whitebyoyomiperiodcount {
                width: 15%;
                padding: 2px 0 2px 6px;
                border: 1px solid #ddd;
                border-right: 0;
            }

            #advancedtimesettings #whitetimesettings #whitetimemargin {
                width: 15%;
                padding: 2px 0 2px 6px;
                border: 1px solid #ddd;
            }

        #advancedtimesettings #blacktimesettings {
            display: flex;
            margin-bottom: 10px;
        }

            #advancedtimesettings #blacktimesettings #dropdown-blacktimemode {
                margin-left: 10px;
                width: 120px;
                background: #eee;
            }

            #advancedtimesettings #blacktimesettings #blackstarttime {
                width: 15%;
                padding: 2px 0 2px 6px;
                border: 1px solid #ddd;
                border-right: 0;
            }

            #advancedtimesettings #blacktimesettings #blacktimegain {
                width: 15%;
                padding: 2px 0 2px 6px;
                border: 1px solid #ddd;
                border-right: 0;
            }

            #advancedtimesettings #blacktimesettings #blackbyoyomitime {
                width: 15%;
                padding: 2px 0 2px 6px;
                border: 1px solid #ddd;
                border-right: 0;
            }

            #advancedtimesettings #blacktimesettings #blackbyoyomiperiodcount {
                width: 15%;
                padding: 2px 0 2px 6px;
                border: 1px solid #ddd;
                border-right: 0;
            }

            #advancedtimesettings #blacktimesettings #blacktimemargin {
                width: 15%;
                padding: 2px 0 2px 6px;
                border: 1px solid #ddd;
            }

        #advancedtimesettings #gamecontrol-start {
            display: flex;
            margin-bottom: 10px;
        }

            #advancedtimesettings #gamecontrol-start #gamestart {
                display: inline-block;
                padding: 3px 6px 3px 6px;
                background: #888;
                color: #fff;
                font-weight: bold;
                margin-right: 6px;
                cursor: pointer;
            }

    spangameresult {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        font-size: 10px;
        position: fixed;
        transition: 0.5s linear;
        font-weight: bold;
        font-family: "Times New Roman",Georgia,Serif,Arial;
        z-index: 3;
    }

    #enginesettings {
        margin-bottom: 10px;
    }

        #enginesettings button {
            display: inline-block;
            padding: 3px 6px 3px 6px;
            background: #888;
            color: #fff;
            font-weight: bold;
            margin-left: 6px;
            margin-right: 6px;
            cursor: pointer;
        }

        #enginesettings #whiteengine {
            margin-bottom: 10px;
        }

        #enginesettings #blackengine {
            margin-bottom: 10px;
        }

        #enginesettings #whiteenginepath {
            width: 30%;
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
        }

        #enginesettings #blackenginepath {
            width: 30%;
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
        }

        #enginesettings #whiteengineprotocol {
            margin-left: 10px;
            min-width: 120px;
            background: #eee;
        }

        #enginesettings #blackengineprotocol {
            margin-left: 10px;
            min-width: 120px;
            background: #eee;
        }

        #enginesettings #whitedepth {
            width: 5%;
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
        }

        #enginesettings #whitemovetime {
            width: 5%;
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
        }

        #enginesettings #whitenodes {
            width: 5%;
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
        }

        #enginesettings #blackdepth {
            width: 5%;
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
        }

        #enginesettings #blackmovetime {
            width: 5%;
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
        }

        #enginesettings #blacknodes {
            width: 5%;
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
        }

    #enginesettingspopup {
        display: none;
        position: fixed;
        top: 0%;
        left: 0%;
        width: 100%;
        height: 100%;
        z-index: 2;
        background-color: white;
        border-radius: 5px;
        overflow: scroll;
    }

        #enginesettingspopup button {
            display: inline-block;
            padding: 3px 6px 3px 6px;
            background: #888;
            color: #fff;
            font-weight: bold;
            margin-left: 6px;
            margin-right: 6px;
            cursor: pointer;
        }

        #enginesettingspopup input {
            padding: 2px 0 2px 6px;
            border: 1px solid #ddd;
            margin-left: 6px;
            margin-right: 6px;
        }

        #enginesettingspopup select {
            min-width: 120px;
            background: #eee;
            margin-left: 6px;
            margin-right: 6px;
        }
</style>

<body>
    <div id="root"></div>
    <script src="bundle.js" defer></script>

    <!--iframe src="./themes.html" onload="this.before((this.contentDocument.body || this.contentDocument).children[0]); this.remove();"--><!--/iframe-->

    <!-- Javascript -->

    <script src="./lib/stockfish.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mithril@2.0.4/mithril.min.js"></script>
    <script>
        let themes = [[], [], []];
        const $ = (...args) => document.querySelector(...args);

        //Remove duplicated elements
        function uniqArr(arr) {
            var newArr = new Set(arr)
            return Array.from(newArr)
        }

        function getFileFromServer(url, doneCallback) {
            var xhr;
            function handleStateChange() {
                if (xhr.readyState === 4) {
                    doneCallback(xhr.status == 200 ? xhr.responseText : null);
                }
            }
            xhr = new XMLHttpRequest();
            xhr.onreadystatechange = handleStateChange;
            xhr.open('GET', url, true);
            xhr.send();
        }

        const copyText = async (val) => {
            if (navigator.clipboard && navigator.permissions) {
                await navigator.clipboard.writeText(val)
            } else {
                const textArea = document.createElement('textArea')
                textArea.value = val
                textArea.style.width = 0
                textArea.style.position = 'fixed'
                textArea.style.left = '-999px'
                textArea.style.top = '10px'
                textArea.setAttribute('readonly', 'readonly')
                document.body.appendChild(textArea)

                textArea.select()
                document.execCommand('copy')
                document.body.removeChild(textArea)
            }
        }

        const formatMB = (n) => {
            return (n ? (n / 1e6).toPrecision(3) : "?") + "MB";
        };

        const isSupported = () => {
            if (typeof WebAssembly !== "object") return false;
            const source = Uint8Array.from([
                0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 7, 8,
                1, 4, 116, 101, 115, 116, 0, 0, 10, 15, 1, 13, 0, 65, 0, 253, 17, 65, 0,
                253, 17, 253, 186, 1, 11,
            ]);
            if (
                typeof WebAssembly.validate !== "function" ||
                !WebAssembly.validate(source)
            )
                return false;
            if (typeof Atomics !== "object") return false;
            if (typeof SharedArrayBuffer !== "function") { console.log("SharedArrayBuffer not enabled!"); return false; }
            if (typeof FileReader === "undefined") { return false; }
            if (typeof WebSocket === "undefined") { return false; }
            return true;
        };

        const RequestProgress = ({ attrs: { url, onFinishDownload } }) => {
            let state = "INIT"; // 'LOADING', 'DONE', 'FAILED'
            let loaded = 0;
            let total = 0;

            const oninit = () => {
                state = "LOADING";
                m.request({
                    url: url,
                    method: "GET",
                    responseType: "arraybuffer",
                    headers: { Accept: "*/*" },
                    config: (xhr) => {
                        xhr.onprogress = (e) => {
                            // TODO:
                            // When gzip compressed, the value of "loaded/total" gets messed up.
                            // On Chrome, "loaded" is the value after decompression, but on the other hand,
                            // On Firefox, "loaded" is the value before decompression.
                            loaded = e.loaded;
                            total =
                                e.total ||
                                Number(
                                    e.target.getResponseHeader("x-decompressed-content-length")
                                );
                            m.redraw();
                        };
                    },
                }).then(
                    (response) => {
                        state = "DONE";
                        onFinishDownload(response);
                    },
                    (e) => {
                        console.error(e);
                        state = "FAILED";
                        onFinishDownload(null);
                    }
                );
            };

            const view = () => {
                const fraction =
                    total == -1 ? `?MB/?MB` : `${formatMB(loaded)}/${formatMB(total)}`;
                return m("span", [
                    `${fraction} [${state}] `,
                    m(
                        "span",
                        {
                            style: "cursor: pointer;",
                            onclick: () =>
                                window.alert(
                                    "On some browsers, download size might look contradictory due to file compression."
                                ),
                        },
                        "[?]"
                    ),
                ]);
            };

            return { oninit, view };
        };

        const LoadThemes = () => {
            themes = [[], [], []];
            function StartLoad(data) {
                console.log(`${typeof data}`);
                data = data.replace(/\r\n/g, "\n")
                data = data.replace(/\r/g, "\n");
                let rawText = data.split('\n');
                console.log('raw:', rawText);
                let i = 0;
                let j = 0;
                let css_name = "";
                let index = 0;
                let require_list = [];
                let themesettings = [];
                let apply_to_all_list = [];
                let loaded_css_list = [];
                let require_board_list = [];
                let board_apply_to_all_list = [];
                let themeavailable = [];
                let boardthemeavailable = [];
                let link = null;
                for (i = 0; i < rawText.length; i++) {
                    if (rawText[i].length < 1 || rawText[i].charAt(0) == '#') {
                        continue;
                    }
                    themesettings = rawText[i].trim().split('|');
                    if (themesettings.length != 3) {
                        console.warn(`At line ${i} in themes.txt: Bad syntax\n`);
                        continue;
                    }
                    themeavailable = themesettings[1].split(',');
                    boardthemeavailable = themesettings[2].split(',');
                    if (themeavailable.length == 1 && themeavailable[0] == "") {
                        themeavailable = [];
                    }
                    if (boardthemeavailable.length == 1 && boardthemeavailable[0] == "") {
                        boardthemeavailable = [];
                    }
                    if ((themesettings[1].length < 1 && themesettings[2].length < 1) || (themeavailable.includes("") || boardthemeavailable.includes(""))) {
                        console.warn(`At line ${i} in themes.txt: Piece and Board style names must not be both null or contain null element\n`);
                        continue;
                    }
                    if (themesettings[1].length > 0) {
                        require_list = themeavailable.filter((element) => { return element.charAt(0) == '@' });
                        themeavailable = themeavailable.filter((element) => { return element.charAt(0) != '@' });
                        for (j = 0; j < require_list.length; j++) {
                            if (themes[0].includes(require_list[j].substring(1))) {
                                index = themes[0].indexOf(require_list[j].substring(1));
                                themeavailable = themeavailable.concat(themes[1][index]);
                            }
                            else {
                                console.warn(`At line ${i} in themes.txt: Variant ${require_list[j].substring(1)} has not been defined yet. You need to put it before this line.\n`);
                            }
                        }
                        themeavailable = uniqArr(themeavailable);
                    }
                    if (themesettings[2].length > 0) {
                        require_board_list = boardthemeavailable.filter((element) => { return element.charAt(0) == '@' });
                        boardthemeavailable = boardthemeavailable.filter((element) => { return element.charAt(0) != '@' });
                        for (j = 0; j < require_board_list.length; j++) {
                            if (themes[0].includes(require_board_list[j].substring(1))) {
                                index = themes[0].indexOf(require_board_list[j].substring(1));
                                boardthemeavailable = boardthemeavailable.concat(themes[2][index]);
                            }
                            else {
                                console.warn(`At line ${i} in themes.txt: Variant ${require_board_list[j].substring(1)} has not been defined yet. You need to put it before this line.\n`);
                            }
                        }
                        boardthemeavailable = uniqArr(boardthemeavailable);
                    }
                    if (themesettings[0] == "*") {
                        if (themesettings[1].length > 0) {
                            apply_to_all_list = apply_to_all_list.concat(themeavailable);
                        }
                        if (themesettings[2].length > 0) {
                            board_apply_to_all_list = board_apply_to_all_list.concat(boardthemeavailable);
                        }
                    }
                    else if (themes[0].includes(themesettings[0])) {
                        if (themesettings[1].length > 0) {
                            index = themes[0].indexOf(themesettings[0]);
                            themes[1][index] = uniqArr(themes[1][index].concat(themeavailable));
                        }
                        if (themesettings[2].length > 0) {
                            index = themes[0].indexOf(themesettings[0]);
                            themes[2][index] = uniqArr(themes[2][index].concat(boardthemeavailable));
                        }
                    }
                    else {
                        themeavailable = uniqArr(themeavailable.concat(apply_to_all_list));
                        boardthemeavailable = uniqArr(boardthemeavailable.concat(board_apply_to_all_list));
                        themes[0].push(themesettings[0]);
                        themes[1].push(themeavailable);
                        themes[2].push(boardthemeavailable);
                    }
                }
                for (i = 0; i < themes[0].length; i++) {
                    for (j = 0; j < themes[1][i].length; j++) {
                        css_name = "theme-piece-" + themes[1][i][j];
                        if (loaded_css_list.includes(css_name)) {
                            continue;
                        }
                        loaded_css_list.push(css_name);
                        link = document.createElement('link');
                        link.setAttribute('rel', 'stylesheet');
                        link.setAttribute('href', "./assets/" + css_name + ".css");
                        document.head.appendChild(link);
                    }
                    for (j = 0; j < themes[2][i].length; j++) {
                        css_name = "theme-board-" + themes[2][i][j];
                        if (loaded_css_list.includes(css_name)) {
                            continue;
                        }
                        loaded_css_list.push(css_name);
                        link = document.createElement('link');
                        link.setAttribute('rel', 'stylesheet');
                        link.setAttribute('href', "./assets/" + css_name + ".css");
                        document.head.appendChild(link);
                    }
                }
                console.log(themes);
            }
            let data = "";
            this.getFileFromServer('./themes.txt', (res) => {
                console.log('res:', res);
                StartLoad(res);
            });
        }

        const ConvertFENtoSFEN = (fen) => {
            if (typeof fen != "string") {
                return null;
            }
            let fen_list = fen.trim().split(' ');
            let sfen = ["", "", "", ""];
            if (fen_list.length != 6 && fen_list.length != 7) {
                return null;
            }
            if (!fen_list[0].includes("[") || !fen_list[0].includes("]")) {
                if (fen_list[0].indexOf('[') >= 0 || fen_list[0].indexOf(']') >= 0) {
                    return null;
                }
                sfen[0] = fen_list[0];
                sfen[2] = "";
            }
            else {
                if (fen_list[0].indexOf('[') > fen_list[0].indexOf(']') || fen_list[0].indexOf(']') < 0) {
                    return null;
                }
                sfen[0] = fen_list[0].substring(0, fen_list[0].indexOf('['));
                sfen[2] = fen_list[0].substring(fen_list[0].indexOf('[') + 1, fen_list[0].indexOf(']'));
            }
            if (fen_list[1] == "w") {
                sfen[1] = "b";
            }
            else if (fen_list[1] == "b") {
                sfen[1] = "w";
            }
            else {
                return null;
            }
            if (sfen[2].length == 0) {
                sfen[2] = "-";
            }
            else {
                const charCount = sfen[2].split("").reduce((pre, cur) => {
                    if (cur in pre) {
                        pre[cur]++;
                    } else {
                        pre[cur] = 1;
                    }
                    return pre;
                }, {});
                sfen[2] = "";
                let ch;
                for (ch in charCount) {
                    if (charCount[ch] > 1) {
                        sfen[2] += (ch.toString() + charCount[ch].toString());
                    }
                    else {
                        sfen[2] += (ch.toString());
                    }
                }
            }
            if (parseInt(fen_list.at(-1)) != NaN) {
                sfen[3] = parseInt(fen_list.at(-1)).toString();
            }
            else {
                return null;
            }
            return sfen.join(' ');
        }

        const convertUCImovestoUSImoves = (moves, board_width, board_height) => {
            const chartoindex = ["z", "y", "x", "w", "v", "u", "t", "s", "r", "q", "p", "o", "n", "m", "l", "k", "j", "i", "h", "g", "f", "e", "d", "c", "b", "a"];
            if (typeof moves != "string" || typeof board_width != "number" || typeof board_height != "number") {
                return null;
            }
            if (board_width < 1 || board_height < 1) {
                return null;
            }
            let movelist = moves.trim().split(' ');
            try {
                movelist.forEach((val, ind) => {
                    if (val.length < 1) {
                        return;
                    }
                    let newmovenotation = "";
                    let move = val;
                    let isPromotion = (val.at(-1) == "+");
                    let isDemotion = (val.at(-1) == "-");
                    let i = 0;
                    if (!/^([+]?[A-Za-z]@)([a-z][0-9]+)[+-]?$/.test(val) && !/^([a-z][0-9]+){2}[+-]?$/.test(val)) {
                        throw SyntaxError;
                    }
                    if (isDemotion || isPromotion) {
                        move = move.substring(0, move.length - 1);
                    }
                    if (val.includes("@")) {
                        let atind = val.indexOf("@");
                        newmovenotation = val.replace("@", "*").substring(0, atind + 1);
                        move = move.substring(atind + 1);
                    }
                    let files = move.split(/[0-9]+/).filter((str) => {
                        return str != "";
                    });
                    let ranks = move.split(/[a-z]/).filter((str) => {
                        return str != "";
                    });
                    if (ranks.length != files.length) {
                        throw SyntaxError;
                    }
                    ranks.forEach((rval, rind) => {
                        if (parseInt(rval) < 1 || parseInt(rval) > board_height) {
                            throw RangeError;
                        }
                        ranks[rind] = chartoindex[chartoindex.length - board_height + parseInt(rval) - 1];
                    });
                    files.forEach((fval, find) => {
                        if (fval < "a" || fval > chartoindex.at(-board_width)) {
                            throw RangeError;
                        }
                        files[find] = (chartoindex.indexOf(fval) + board_width - chartoindex.length + 1).toString();
                    })
                    movelist[ind] = newmovenotation;
                    for (i = 0; i < ranks.length; i++) {
                        movelist[ind] += `${files[i]}${ranks[i]}`;
                    }
                    if (isDemotion) {
                        movelist[ind] += "-";
                    }
                    else if (isPromotion) {
                        movelist[ind] += "+";
                    }
                });
            }
            catch {
                return null;
            }
            return movelist.join(' ');
        }

        const convertUCImovestoUCCImoves = (moves, board_width, board_height) => {
            const chartoindex = ["z", "y", "x", "w", "v", "u", "t", "s", "r", "q", "p", "o", "n", "m", "l", "k", "j", "i", "h", "g", "f", "e", "d", "c", "b", "a"];
            if (typeof moves != "string" || typeof board_width != "number" || typeof board_height != "number") {
                return null;
            }
            if (board_width < 1 || board_height < 1) {
                return null;
            }
            let movelist = moves.trim().split(' ');
            try {
                movelist.forEach((val, ind) => {
                    if (val.length < 1) {
                        return;
                    }
                    let move = val;
                    let i = 0;
                    if (!/^([a-z][0-9]+){2}$/.test(val)) {
                        throw SyntaxError;
                    }
                    let files = move.split(/[0-9]+/).filter((str) => {
                        return str != "";
                    });
                    let ranks = move.split(/[a-z]/).filter((str) => {
                        return str != "";
                    });
                    if (ranks.length != files.length) {
                        throw SyntaxError;
                    }
                    ranks.forEach((rval, rind) => {
                        if (parseInt(rval) < 1 || parseInt(rval) > board_height) {
                            throw RangeError;
                        }
                        ranks[rind] = parseInt(rval) - 1;
                    });
                    files.forEach((fval, find) => {
                        if (fval < "a" || fval > chartoindex.at(-board_width)) {
                            throw RangeError;
                        }
                    })
                    movelist[ind] = "";
                    for (i = 0; i < ranks.length; i++) {
                        movelist[ind] += `${files[i]}${ranks[i]}`;
                    }
                });
            }
            catch {
                return null;
            }
            return movelist.join(' ');
        }

        const convertUSImovestoUCImoves = (moves, board_width, board_height) => {
            const chartoindex = ["z", "y", "x", "w", "v", "u", "t", "s", "r", "q", "p", "o", "n", "m", "l", "k", "j", "i", "h", "g", "f", "e", "d", "c", "b", "a"];
            if (typeof moves != "string" || typeof board_width != "number" || typeof board_height != "number") {
                return null;
            }
            if (board_width < 1 || board_height < 1) {
                return null;
            }
            let movelist = moves.trim().split(' ');
            try {
                movelist.forEach((val, ind) => {
                    if (val.length < 1) {
                        return;
                    }
                    let newmovenotation = "";
                    let move = val;
                    let isPromotion = (val.at(-1) == "+");
                    let isDemotion = (val.at(-1) == "-");
                    let i = 0;
                    if (!/^([+]?[A-Za-z]\*)([0-9]+[a-z])[+-]?$/.test(val) && !/^([0-9]+[a-z]){2}[+-]?$/.test(val)) {
                        throw SyntaxError;
                    }
                    if (isDemotion || isPromotion) {
                        move = move.substring(0, move.length - 1);
                    }
                    if (val.includes("*")) {
                        let atind = val.indexOf("*");
                        newmovenotation = val.replace("*", "@").substring(0, atind + 1);
                        move = move.substring(atind + 1);
                    }
                    let files = move.split(/[a-z]/).filter((str) => {
                        return str != "";
                    });
                    let ranks = move.split(/[0-9]+/).filter((str) => {
                        return str != "";
                    });
                    if (ranks.length != files.length) {
                        throw SyntaxError;
                    }
                    ranks.forEach((rval, rind) => {
                        if (rval < "a" || rval > chartoindex.at(-board_width)) {
                            throw RangeError;
                        }
                        ranks[rind] = (chartoindex.indexOf(rval) + board_width - chartoindex.length + 1).toString();
                    });
                    files.forEach((fval, find) => {
                        
                        if (parseInt(fval) < 1 || parseInt(fval) > board_height) {
                            throw RangeError;
                        }
                        files[find] = chartoindex[chartoindex.length - board_height + parseInt(fval) - 1];
                    })
                    movelist[ind] = newmovenotation;
                    for (i = 0; i < ranks.length; i++) {
                        movelist[ind] += `${files[i]}${ranks[i]}`;
                    }
                    if (isDemotion) {
                        movelist[ind] += "-";
                    }
                    else if (isPromotion) {
                        movelist[ind] += "+";
                    }
                });
            }
            catch {
                return null;
            }
            return movelist.join(' ');
        }

        const convertUCCImovestoUCImoves = (moves, board_width, board_height) => {
            const chartoindex = ["z", "y", "x", "w", "v", "u", "t", "s", "r", "q", "p", "o", "n", "m", "l", "k", "j", "i", "h", "g", "f", "e", "d", "c", "b", "a"];
            if (typeof moves != "string" || typeof board_width != "number" || typeof board_height != "number") {
                return null;
            }
            if (board_width < 1 || board_height < 1) {
                return null;
            }
            let movelist = moves.trim().split(' ');
            try {
                movelist.forEach((val, ind) => {
                    if (val.length < 1) {
                        return;
                    }
                    let move = val;
                    let i = 0;
                    if (!/^([a-z][0-9]+){2}$/.test(val)) {
                        throw SyntaxError;
                    }
                    let files = move.split(/[0-9]+/).filter((str) => {
                        return str != "";
                    });
                    let ranks = move.split(/[a-z]/).filter((str) => {
                        return str != "";
                    });
                    if (ranks.length != files.length) {
                        throw SyntaxError;
                    }
                    ranks.forEach((rval, rind) => {
                        if (parseInt(rval) < 0 || parseInt(rval) > board_height - 1) {
                            throw RangeError;
                        }
                        ranks[rind] = parseInt(rval) + 1;
                    });
                    files.forEach((fval, find) => {
                        if (fval < "a" || fval > chartoindex.at(-board_width)) {
                            throw RangeError;
                        }
                    })
                    movelist[ind] = "";
                    for (i = 0; i < ranks.length; i++) {
                        movelist[ind] += `${files[i]}${ranks[i]}`;
                    }
                });
            }
            catch {
                return null;
            }
            return movelist.join(' ');
        }

        const App = () => {
            let stockfish = null;
            let stockfish_state = "INIT"; // 'READY', 'FAILED'
            let output2 = "";
            let show_dests = true;
            let adjudicate = true;
            let analysis_mode = false;
            let play_white = false;
            let play_black = false;
            let play_move = false;
            let review_mode = false;
            let board_setup_mode = false;
            let advanced_time_control = false;
            let during_play = false;
            let white_remaining_time = 0;
            let black_remaining_time = 0;
            let white_moving_time_list = [];
            let black_moving_time_list = [];
            let white_time_gain = 0;
            let black_time_gain = 0;
            let white_timer_type = "infinite";
            let black_timer_type = "infinite";
            let timer_interval = 100;
            let white_byoyomi_time_per_period = 0;
            let black_byoyomi_time_per_period = 0;
            let white_byoyomi_period_count = 0;
            let black_byoyomi_period_count = 0;
            let white_remaining_byoyomi_periods = 0;
            let black_remaining_byoyomi_periods = 0;
            let white_time_margin = 0;
            let black_time_margin = 0;
            let previous_mover = "";
            let timer;
            let WebSocketStatus = "Unestablished";
            let white_engine = "";
            let black_engine = "";
            let loading_engine_white = false;
            let loading_engine_black = false;
            let white_engine_protocol = "UCI";
            let black_engine_protocol = "UCI";
            let white_engine_name = "";
            let white_engine_author = "";
            let black_engine_name = "";
            let black_engine_author = "";
            let white_engine_options = [];
            let black_engine_options = [];
            let white_engine_datastream = "";
            let black_engine_datastream = "";
            let white_engine_variants = [];
            let black_engine_variants = [];
            let white_engine_has_variants_option = false;
            let black_engine_has_variants_option = false;
            let using_white_engine = false;
            let using_black_engine = false;
            let white_engine_ponder = false;
            let black_engine_ponder = false;
            let white_engine_ponder_move = "0000";
            let black_engine_ponder_move = "0000";
            let white_engine_ponder_miss = false;
            let black_engine_ponder_miss = false;
            let changing_engine_settings = false;
            const load_engine_timeout = 10000;
            let ws = null;

            let variants = [];

            const checkconnectionnumber = parseInt(Math.random() * 100000);
            let wsport = window.location.port;
            if (wsport == "") {
                wsport = 5001;
            }
            else {
                wsport = (+wsport) + 1;
            }

            try {
                ws = new WebSocket("ws://" + window.location.hostname + ":" + wsport.toString());

                ws.addEventListener('open', function (event) {
                    ws.send(`CONNECT|${checkconnectionnumber}`);
                });

                ws.addEventListener('message', function (event) {
                    if (typeof event.data != "string") {
                        console.error(`Received bad data type from server: ${typeof event.data}`);
                        ws.close();
                        WebSocketStatus = "ERROR";
                        return;
                    }
                    let msg = event.data.split('|');
                    if (WebSocketStatus == "Unestablished") {
                        if (event.data == `${checkconnectionnumber}`) {
                            console.log("WebSocket connection established.");
                            WebSocketStatus = "CONNECTED";
                            ws.send("READYOK");
                        }
                        else {
                            console.error("WebSocket Server conncetion failed: Server returns bad verification code.");
                            ws.close();
                            WebSocketStatus = "ERROR";
                        }
                    }
                    else if (WebSocketStatus == "CONNECTED") {
                        if (msg[0] == "ERROR") {
                            if (msg[1] == "LOAD_ENGINE") {
                                console.error("Failed to load engine for " + msg[2]);
                                if (msg[2] == "WHITE") {
                                    loading_engine_white = false;
                                    white_engine = "";
                                    window.alert("Engine WHITE exited unexpectedly.");
                                    if ($("#label-stm").innerText == "white") {
                                        play_move = false;
                                    }
                                }
                                else if (msg[2] == "BLACK") {
                                    loading_engine_black = false;
                                    black_engine = "";
                                    window.alert("Engine BLACK exited unexpectedly.");
                                    if ($("#label-stm").innerText == "black") {
                                        play_move = false;
                                    }
                                }
                            }
                            else if (msg[1] == "ENGINE_TIMEOUT") {
                                console.error("Engine timed out: " + msg[2]);
                                if (msg[2] == "WHITE") {
                                    loading_engine_white = false;
                                    white_engine = "";
                                    window.alert("Engine WHITE load timed out.");
                                }
                                else if (msg[2] == "BLACK") {
                                    loading_engine_black = false;
                                    black_engine = "";
                                    window.alert("Engine BLACK load timed out.");
                                }
                            }
                        }
                        else if (msg[0] == "ENGINE_INFO") {
                            if (msg[1] == "WHITE") {
                                white_engine_datastream += msg[2].replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                            }
                            else if (msg[1] == "BLACK") {
                                black_engine_datastream += msg[2].replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                            }
                            //console.log(event.data);
                            let i = 0;
                            if (loading_engine_white || loading_engine_black) {
                                if (msg[1] == "WHITE" && (white_engine_datastream.includes("uciok") || white_engine_datastream.includes("usiok") || white_engine_datastream.includes("ucciok"))) {
                                    let engine_info = white_engine_datastream.split('\n');
                                    for (i = 0; i < engine_info.length; i++) {
                                        if (engine_info[i].startsWith("id name")) {
                                            white_engine_name = engine_info[i].split(' ').slice(2).join(' ');
                                        }
                                        else if (engine_info[i].startsWith("id author")) {
                                            white_engine_author = engine_info[i].split(' ').slice(2).join(' ');
                                        }
                                        else if (engine_info[i].startsWith("option ")) {
                                            let options = engine_info[i].split(' ');
                                            let optionname = options.slice(2, options.indexOf("type")).join(' ');
                                            if (white_engine_protocol == "UCCI") {
                                                optionname = options.slice(1, options.indexOf("type")).join(' ');
                                            }
                                            let optiontype = options[options.indexOf("type") + 1];
                                            if (optiontype == "button") {
                                                white_engine_options.push({
                                                    name: optionname,
                                                    type: optiontype,
                                                    default: null,
                                                    min: null,
                                                    max: null,
                                                    values: null,
                                                    current: null,
                                                });
                                                continue;
                                            }
                                            let optiondefault = options[options.indexOf("default") + 1];
                                            if (optiontype == "check" || optiontype == "string") {
                                                white_engine_options.push({
                                                    name: optionname,
                                                    type: optiontype,
                                                    default: optiondefault,
                                                    min: null,
                                                    max: null,
                                                    values: null,
                                                    current: null,
                                                });
                                                if (optionname == "Ponder" || optionname == "USI_Ponder" || optionname == "UCCI_Ponder") {
                                                    if (optiondefault == "true") {
                                                        white_engine_ponder = true;
                                                    }
                                                    else {
                                                        white_engine_ponder = false;
                                                    }
                                                }
                                            }
                                            else if (optiontype == "spin") {
                                                white_engine_options.push({
                                                    name: optionname,
                                                    type: optiontype,
                                                    default: optiondefault,
                                                    min: options[options.indexOf("min") + 1],
                                                    max: options[options.indexOf("max") + 1],
                                                    values: null,
                                                    current: null,
                                                });
                                            }
                                            else if (optiontype == "combo") {
                                                let dropdownoptions = options.slice(options.indexOf("default") + 1).join(' ').split(" var ").slice(1);
                                                white_engine_options.push({
                                                    name: optionname,
                                                    type: optiontype,
                                                    default: optiondefault,
                                                    min: null,
                                                    max: null,
                                                    values: dropdownoptions,
                                                    current: null,
                                                });
                                                if (optionname == "UCI_Variant" || optionname == "USI_Variant" || optionname == "UCCI_Variant") {
                                                    white_engine_variants = dropdownoptions.slice(0);
                                                    white_engine_has_variants_option = true;
                                                }
                                            }
                                            else {
                                                console.warn("Unknown option type:" + optiontype + ".\nThis option will be ignored.");
                                            }
                                        }
                                        else if (engine_info[i].startsWith("uciok") || engine_info[i].startsWith("usiok") || engine_info[i].startsWith("ucciok")) {
                                            console.log("White Engine loaded.");
                                            console.log(`Name: ${white_engine_name}\nAuthor: ${white_engine_author}`);
                                            console.log(white_engine_options);
                                            white_engine_datastream = "";
                                            if (white_engine_variants.length == 0) {
                                                if (white_engine_protocol == "UCI") {
                                                    white_engine_variants = ["chess", "fischerandom", ""];
                                                }
                                                else if (white_engine_protocol == "USI") {
                                                    white_engine_variants = ["shogi"];
                                                }
                                                else if (white_engine_protocol == "UCCI" || white_engine_protocol == "UCI_CYCLONE") {
                                                    white_engine_variants = ["xiangqi"];
                                                }
                                                white_engine_has_variants_option = false;
                                            }
                                            ws.send("POST_MSG|WHITE|isready");
                                            break;
                                        }
                                    }
                                }
                                else if (msg[1] == "BLACK" && (black_engine_datastream.includes("uciok") || black_engine_datastream.includes("usiok") || black_engine_datastream.includes("ucciok"))) {
                                    let engine_info = black_engine_datastream.split('\n');
                                    for (i = 0; i < engine_info.length; i++) {
                                        if (engine_info[i].startsWith("id name")) {
                                            black_engine_name = engine_info[i].split(' ').slice(2).join(' ');
                                        }
                                        else if (engine_info[i].startsWith("id author")) {
                                            black_engine_author = engine_info[i].split(' ').slice(2).join(' ');
                                        }
                                        else if (engine_info[i].startsWith("option ")) {
                                            let options = engine_info[i].split(' ');
                                            let optionname = options.slice(2, options.indexOf("type")).join(' ');
                                            if (black_engine_protocol == "UCCI") {
                                                optionname = options.slice(1, options.indexOf("type")).join(' ');
                                            }
                                            let optiontype = options[options.indexOf("type") + 1];
                                            if (optiontype == "button") {
                                                black_engine_options.push({
                                                    name: optionname,
                                                    type: optiontype,
                                                    default: null,
                                                    min: null,
                                                    max: null,
                                                    values: null,
                                                    current: null,
                                                });
                                                continue;
                                            }
                                            let optiondefault = options[options.indexOf("default") + 1];
                                            if (optiontype == "check" || optiontype == "string") {
                                                black_engine_options.push({
                                                    name: optionname,
                                                    type: optiontype,
                                                    default: optiondefault,
                                                    min: null,
                                                    max: null,
                                                    values: null,
                                                    current: null,
                                                });
                                                if (optionname == "Ponder" || optionname == "USI_Ponder" || optionname == "UCCI_Ponder") {
                                                    if (optiondefault == "true") {
                                                        black_engine_ponder = true;
                                                    }
                                                    else {
                                                        black_engine_ponder = false;
                                                    }
                                                }
                                            }
                                            else if (optiontype == "spin") {
                                                black_engine_options.push({
                                                    name: optionname,
                                                    type: optiontype,
                                                    default: optiondefault,
                                                    min: options[options.indexOf("min") + 1],
                                                    max: options[options.indexOf("max") + 1],
                                                    values: null,
                                                    current: null,
                                                });
                                            }
                                            else if (optiontype == "combo") {
                                                let dropdownoptions = options.slice(options.indexOf("default") + 1).join(' ').split(" var ").slice(1);
                                                black_engine_options.push({
                                                    name: optionname,
                                                    type: optiontype,
                                                    default: optiondefault,
                                                    min: null,
                                                    max: null,
                                                    values: dropdownoptions,
                                                    current: null,
                                                });
                                                if (optionname == "UCI_Variant" || optionname == "USI_Variant" || optionname == "UCCI_Variant") {
                                                    black_engine_variants = dropdownoptions.slice(0);
                                                    black_engine_has_variants_option = true;
                                                }
                                            }
                                            else {
                                                console.warn("Unknown option type:" + optiontype + ".\nThis option will be ignored.");
                                            }
                                        }
                                        else if (engine_info[i].startsWith("uciok") || engine_info[i].startsWith("usiok") || engine_info[i].startsWith("ucciok")) {
                                            console.log("Black Engine loaded.");
                                            console.log(`Name: ${black_engine_name}\nAuthor: ${black_engine_author}`);
                                            console.log(black_engine_options);
                                            black_engine_datastream = "";
                                            if (black_engine_variants.length == 0) {
                                                if (black_engine_protocol == "UCI") {
                                                    black_engine_variants = ["chess", "fischerandom", ""];
                                                }
                                                else if (black_engine_protocol == "USI") {
                                                    black_engine_variants = ["shogi"];
                                                }
                                                else if (black_engine_protocol == "UCCI" || black_engine_protocol == "UCI_CYCLONE") {
                                                    black_engine_variants = ["xiangqi"];
                                                }
                                                black_engine_has_variants_option = false;
                                            }
                                            ws.send("POST_MSG|BLACK|isready");
                                            break;
                                        }
                                    }
                                }
                                else if (msg[1] == "WHITE" && white_engine_datastream.includes("readyok")) {
                                    white_engine = $("#whiteenginepath").value;
                                    loading_engine_white = false;
                                    ws.send("ENGINE_READY|WHITE");
                                    console.log("White engine is ready.");
                                    if (white_engine_variants.includes($("#dropdown-variant").value)) {
                                        using_white_engine = true;
                                        $("#whiteunsupportedvariant").hidden = true;
                                        if (white_engine_has_variants_option) {
                                            if (white_engine_protocol == "UCI" || white_engine_protocol == "UCI_CYCLONE") {
                                                postMessageToEngine("WHITE", `setoption name UCI_Variant value ${$("#dropdown-variant").value}`, true);
                                            }
                                            else if (white_engine_protocol == "USI") {
                                                postMessageToEngine("WHITE", `setoption name USI_Variant value ${$("#dropdown-variant").value}`, true);
                                            }
                                            else if (white_engine_protocol == "UCCI") {
                                                postMessageToEngine("WHITE", `setoption name UCCI_Variant value ${$("#dropdown-variant").value}`, true);
                                            }
                                        }
                                        if (white_engine_protocol == "UCI" || white_engine_protocol == "UCI_CYCLONE") {
                                            postMessageToEngine("WHITE", "ucinewgame", true);
                                        }
                                        else if (white_engine_protocol == "USI") {
                                            postMessageToEngine("WHITE", "usinewgame", true);
                                        }
                                        else if (white_engine_protocol == "UCCI") {
                                            postMessageToEngine("WHITE", "uccinewgame", true);
                                        }
                                        postMessageToEngine("WHITE", "position startpos", true);
                                    }
                                    else {
                                        console.log("Engine WHITE: " + white_engine_name + " does not support variant " + $("#dropdown-variant").value + ". Fairy Stockfish WASM will be used instead.");
                                        using_white_engine = false;
                                        $("#whiteunsupportedvariant").hidden = false;
                                    }
                                    white_engine_datastream = "";
                                    if (white_engine_protocol == "UCI" || white_engine_protocol == "UCI_CYCLONE") {
                                        output2 += ("Engine WHITE:\nName: " + white_engine_name + "\nAuthor: " + white_engine_author + "\nuciok\n");
                                    }
                                    else if (white_engine_protocol == "USI") {
                                        output2 += ("Engine WHITE:\nName: " + white_engine_name + "\nAuthor: " + white_engine_author + "\nusiok\n");
                                    }
                                    else if (white_engine_protocol == "UCCI") {
                                        output2 += ("Engine WHITE:\nName: " + white_engine_name + "\nAuthor: " + white_engine_author + "\nucciok\n");
                                    }
                                    $("#output2").innerText = output2;
                                    scrollOutput();
                                }
                                else if (msg[1] == "BLACK" && black_engine_datastream.includes("readyok")) {
                                    black_engine = $("#blackenginepath").value;
                                    loading_engine_black = false;
                                    ws.send("ENGINE_READY|BLACK");
                                    console.log("Black engine is ready.");
                                    if (black_engine_variants.includes($("#dropdown-variant").value)) {
                                        using_black_engine = true;
                                        $("#blackunsupportedvariant").hidden = true;
                                        if (black_engine_has_variants_option) {
                                            if (black_engine_protocol == "UCI" || black_engine_protocol == "UCI_CYCLONE") {
                                                postMessageToEngine("BLACK", `setoption name UCI_Variant value ${$("#dropdown-variant").value}`, true);
                                            }
                                            else if (black_engine_protocol == "USI") {
                                                postMessageToEngine("BLACK", `setoption name USI_Variant value ${$("#dropdown-variant").value}`, true);
                                            }
                                            else if (black_engine_protocol == "UCCI") {
                                                postMessageToEngine("BLACK", `setoption name UCCI_Variant value ${$("#dropdown-variant").value}`, true);
                                            }
                                        }
                                        if (black_engine_protocol == "UCI" || black_engine_protocol == "UCI_CYCLONE") {
                                            postMessageToEngine("BLACK", "ucinewgame", true);
                                        }
                                        else if (black_engine_protocol == "USI") {
                                            postMessageToEngine("BLACK", "usinewgame", true);
                                        }
                                        else if (black_engine_protocol == "UCCI") {
                                            postMessageToEngine("BLACK", "uccinewgame", true);
                                        }
                                        postMessageToEngine("BLACK", "position startpos", true);
                                    }
                                    else {
                                        console.log("Engine BLACK: " + black_engine_name + " does not support variant " + $("#dropdown-variant").value + ". Fairy Stockfish WASM will be used instead.");
                                        using_black_engine = false;
                                        $("#blackunsupportedvariant").hidden = false;
                                    }
                                    black_engine_datastream = "";
                                    if (black_engine_protocol == "UCI" || black_engine_protocol == "UCI_CYCLONE") {
                                        output2 += ("Engine BLACK:\nName: " + black_engine_name + "\nAuthor: " + black_engine_author + "\nuciok\n");
                                    }
                                    else if (black_engine_protocol == "USI") {
                                        output2 += ("Engine BLACK:\nName: " + black_engine_name + "\nAuthor: " + black_engine_author + "\nusiok\n");
                                    }
                                    else if (black_engine_protocol == "UCCI") {
                                        output2 += ("Engine BLACK:\nName: " + black_engine_name + "\nAuthor: " + black_engine_author + "\nucciok\n");
                                    }
                                    $("#output2").innerText = output2;
                                    scrollOutput();
                                }
                            }
                            else if (changing_engine_settings) {
                                if (msg[1] == "WHITE" && white_engine_datastream.includes("info string ") && (white_engine_datastream.match(/info string /g) || []).length == (white_engine_datastream.replace(/\r\n/g, "\n").replace(/\r/g, "\n").match(/\n/g) || []).length) {
                                    let engine_info = white_engine_datastream.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split('\n');
                                    let buffer = "";
                                    for (i = 0; i < engine_info.length; i++) {
                                        if (engine_info[i].startsWith("info string ")) {
                                            buffer += engine_info[i].split(' ').slice(2).join(' ');
                                        }
                                    }
                                    white_engine_datastream = "";
                                    console.log("Message from engine WHITE: ", buffer);
                                    window.alert(`Message from engine WHITE: ${buffer}`);
                                }
                                else if (msg[1] == "BLACK" && black_engine_datastream.includes("info string ") && (black_engine_datastream.match(/info string /g) || []).length == (black_engine_datastream.replace(/\r\n/g, "\n").replace(/\r/g, "\n").match(/\n/g) || []).length) {
                                    let engine_info = black_engine_datastream.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split('\n');
                                    let buffer = "";
                                    for (i = 0; i < engine_info.length; i++) {
                                        if (engine_info[i].startsWith("info string ")) {
                                            buffer += engine_info[i].split(' ').slice(2).join(' ');
                                        }
                                    }
                                    black_engine_datastream = "";
                                    console.log("Message from engine BLACK: ", buffer);
                                    window.alert(`Message from engine BLACK: ${buffer}`);
                                }
                            }
                            else {
                                if (msg[1] == "WHITE" && $("#label-stm").innerText == "white") {
                                    output2 += msg[2];
                                    $("#output2").innerText = output2;
                                    scrollOutput();
                                    if (review_mode) {
                                        white_engine_datastream = "";
                                        return;
                                    }
                                    if (/[\r\n]+/.test(msg[2])) {
                                        let white_bestmove_index = white_engine_datastream.indexOf("bestmove");
                                        if (white_bestmove_index >= 0 && white_engine_datastream.lastIndexOf('\n') > white_bestmove_index) {
                                            if (play_white) {
                                                if (white_engine_ponder && white_engine_ponder_miss) {
                                                    white_engine_ponder_miss = false;
                                                }
                                                else {
                                                    let bestmoveline = white_engine_datastream.substring(white_bestmove_index).replace(/[\r\n]/g, " ").split(' ');
                                                    play_move = false;
                                                    if (bestmoveline[1] == "resign" || bestmoveline[2] == "resign") {
                                                        alert(white_engine_name + " (WHITE) has resigned.");
                                                    }
                                                    else if (bestmoveline[1] != "0000") {
                                                        if (white_engine_protocol == "UCI") {
                                                            $("#move").value += (" " + bestmoveline[1]);
                                                            white_engine_ponder_move = bestmoveline[3];
                                                        }
                                                        else if (white_engine_protocol == "USI") {
                                                            $("#move").value += (" " + convertUSImovestoUCImoves(bestmoveline[1], 9, 9));
                                                            white_engine_ponder_move = convertUSImovestoUCImoves(bestmoveline[3], 9, 9);
                                                        }
                                                        else if (white_engine_protocol == "UCCI" || white_engine_protocol == "UCI_CYCLONE") {
                                                            $("#move").value += (" " + convertUCCImovestoUCImoves(bestmoveline[1], 9, 10));
                                                            if (bestmoveline[2] == "draw") {
                                                                white_engine_ponder_move = convertUCCImovestoUCImoves(bestmoveline[4], 9, 10);
                                                            }
                                                            else {
                                                                white_engine_ponder_move = convertUCCImovestoUCImoves(bestmoveline[3], 9, 10);
                                                            }
                                                        }
                                                        if (white_engine_ponder_move == undefined) {
                                                            white_engine_ponder_move = "0000";
                                                        }
                                                        $("#set").click();
                                                    }
                                                }
                                            }
                                            white_engine_datastream = "";
                                        }
                                        else {
                                            white_engine_datastream = white_engine_datastream.substring(white_engine_datastream.indexOf('\n') + 1);
                                        }
                                    }
                                }
                                else if (msg[1] == "BLACK" && $("#label-stm").innerText == "black") {
                                    output2 += msg[2];
                                    $("#output2").innerText = output2;
                                    scrollOutput();
                                    if (review_mode) {
                                        black_engine_datastream = "";
                                        return;
                                    }
                                    if (/[\r\n]+/.test(msg[2])) {
                                        let black_bestmove_index = black_engine_datastream.indexOf("bestmove");
                                        if (black_bestmove_index >= 0 && black_engine_datastream.lastIndexOf('\n') > black_bestmove_index) {
                                            if (play_black) {
                                                if (black_engine_ponder && black_engine_ponder_miss) {
                                                    black_engine_ponder_miss = false;
                                                }
                                                else {
                                                    let bestmoveline = black_engine_datastream.substring(black_bestmove_index).replace(/[\r\n]/g, " ").split(' ');
                                                    play_move = false;
                                                    if (bestmoveline[1] == "resign" || bestmoveline[2] == "resign") {
                                                        alert(black_engine_name + " (BLACK) has resigned.");
                                                    }
                                                    else if (bestmoveline[1] != "0000") {
                                                        if (black_engine_protocol == "UCI") {
                                                            $("#move").value += (" " + bestmoveline[1]);
                                                            black_engine_ponder_move = bestmoveline[3];
                                                        }
                                                        else if (black_engine_protocol == "USI") {
                                                            $("#move").value += (" " + convertUSImovestoUCImoves(bestmoveline[1], 9, 9));
                                                            black_engine_ponder_move = convertUSImovestoUCImoves(bestmoveline[3], 9, 9);
                                                        }
                                                        else if (black_engine_protocol == "UCCI" || black_engine_protocol == "UCI_CYCLONE") {
                                                            $("#move").value += (" " + convertUCCImovestoUCImoves(bestmoveline[1], 9, 10));
                                                            if (bestmoveline[2] == "draw") {
                                                                black_engine_ponder_move = convertUCCImovestoUCImoves(bestmoveline[4], 9, 10);
                                                            }
                                                            else {
                                                                black_engine_ponder_move = convertUCCImovestoUCImoves(bestmoveline[3], 9, 10);
                                                            }
                                                        }
                                                        if (black_engine_ponder_move == undefined) {
                                                            black_engine_ponder_move = "0000";
                                                        }
                                                        $("#set").click();
                                                    }
                                                }
                                            }
                                            black_engine_datastream = "";
                                        }
                                        else {
                                            black_engine_datastream = black_engine_datastream.substring(black_engine_datastream.indexOf('\n') + 1);
                                        }
                                    }
                                }
                            }
                        }
                        else if (msg[0] == "ENGINE_ERROR") {
                            if (/^[ ]*$/.test(msg[2])) {
                                return;
                            }
                            console.error("Engine " + msg[1] + " Error: " + msg[2]);
                            if (!/[A-Za-z0-9]+/.test(msg[2])) {
                                return;
                            }
                            window.alert("Engine " + msg[1] + " Error:\n" + msg[2]);
                        }
                    }
                });

                ws.addEventListener('close', function (event) {
                    let { code, reason, wasClen } = event;
                    if (WebSocketStatus == "ERROR") {
                        return;
                    }
                    ws.send('WebSocket Closed.');
                    WebSocketStatus = "CLOSED";
                });

                ws.addEventListener('error', function (event) {
                    WebSocketStatus = "ERROR";
                    console.error("Errors occurred during establishing WebSocket connection.");
                });
            }
            catch {
                console.warn("Cannot initiate WebSocket connection. Binary engine loading feature will be disabled.");
                ws = null;
                WebSocketStatus = "ERROR";
            }

            const EditEngineSettings = (color, ws) => {
                while (document.getElementById("enginesettingspopup") != null) {
                    document.getElementById("enginesettingspopup").remove();
                }
                if (color == "WHITE" && white_engine == "") {
                    console.log("Engine is not loaded for white.");
                    return;
                }
                if (color == "BLACK" && black_engine == "") {
                    console.log("Engine is not loaded for black.");
                    return;
                }
                if (loading_engine_white || loading_engine_black) {
                    console.log("Loading engines.");
                    return;
                }
                let popup = document.createElement("div");
                popup.id = "enginesettingspopup";
                let title = document.createElement("p");
                title.id = "popup-title";
                let engine_protocol = document.createElement("p");
                engine_protocol.id = "engineprotocol";
                let colorofsettings = document.createElement("p");
                colorofsettings.id = "colorofsettings";
                colorofsettings.style.display = "hidden";
                if (color == "WHITE") {
                    title.innerHTML = "Name: " + white_engine_name + "\nAuthor: " + white_engine_author;
                    title.style.whiteSpace = "pre-line";
                    colorofsettings.innerHTML = "WHITE";
                    engine_protocol.innerHTML = white_engine_protocol;
                    popup.appendChild(title);
                    popup.appendChild(engine_protocol);
                    popup.appendChild(colorofsettings);
                    let subdiv;
                    let text;
                    let input;
                    let btntext;
                    white_engine_options.forEach((value, index) => {
                        subdiv = document.createElement("div");
                        subdiv.id = value.name.replace(/[ ]/g, "") + "-div";
                        text = document.createElement("p");
                        text.innerHTML = value.name;
                        subdiv.appendChild(text);
                        if (value.type == "string") {
                            input = document.createElement("input");
                            input.value = value.default;
                            subdiv.appendChild(input);
                        }
                        else if (value.type == "check") {
                            input = document.createElement("input");
                            input.type = "checkbox";
                            if (value.default == "true") {
                                input.checked = true;
                            }
                            else {
                                input.checked = false;
                            }
                            subdiv.appendChild(input);
                        }
                        else if (value.type == "spin") {
                            input = document.createElement("input");
                            input.type = "number";
                            input.max = value.max;
                            input.min = value.min;
                            input.value = value.default;
                            input.onchange = function () {
                                if (!/^(\-|\+)?(0|[1-9][0-9]*)$/.test($("#" + value.name.replace(/[ ]/g, "") + "-input").value)) {
                                    $("#" + value.name.replace(/[ ]/g, "") + "-input").value = parseInt(value.default);
                                }
                                else if ($("#" + value.name.replace(/[ ]/g, "") + "-input").value < parseInt(value.min)) {
                                    $("#" + value.name.replace(/[ ]/g, "") + "-input").value = parseInt(value.min);
                                }
                                else if ($("#" + value.name.replace(/[ ]/g, "") + "-input").value > parseInt(value.max)) {
                                    $("#" + value.name.replace(/[ ]/g, "") + "-input").value = parseInt(value.max);
                                }
                            }
                            subdiv.appendChild(input);
                        }
                        else if (value.type == "button") {
                            input = document.createElement("button");
                            input.onclick = function () {
                                if (white_engine_protocol == "UCCI") {
                                    ws.send("POST_MSG|WHITE|setoption " + value.name);
                                }
                                else {
                                    ws.send("POST_MSG|WHITE|setoption name " + value.name);
                                }
                            }
                            btntext = document.createTextNode(value.name);
                            input.appendChild(btntext);
                            subdiv.appendChild(input);
                        }
                        else if (value.type == "combo") {
                            input = document.createElement("select");
                            let option;
                            value.values.forEach((opt) => {
                                option = document.createElement("option");
                                option.text = opt;
                                option.value = opt;
                                input.appendChild(option);
                            });
                            subdiv.appendChild(input);
                            input.childNodes.forEach((combooption, comboindex) => {
                                if (combooption.innerHTML == white_engine_options[index].default) {
                                    input.selectedIndex = comboindex;
                                }
                            });
                        }
                        else {
                            console.warn("Unknown option type: ", value.type);
                        }
                        input.id = value.name.replace(/[ ]/g, "") + "-input";
                        subdiv.style.display = "flex";
                        subdiv.style.marginTop = "10px";
                        popup.appendChild(subdiv);
                    });
                }
                else if (color == "BLACK") {
                    title.innerHTML = "Name: " + black_engine_name + "\nAuthor: " + black_engine_author;
                    title.style.whiteSpace = "pre-line";
                    colorofsettings.innerHTML = "BLACK";
                    engine_protocol.innerHTML = black_engine_protocol;
                    popup.appendChild(title);
                    popup.appendChild(engine_protocol);
                    popup.appendChild(colorofsettings);
                    let subdiv;
                    let text;
                    let input;
                    let btntext;
                    black_engine_options.forEach((value, index) => {
                        subdiv = document.createElement("div");
                        subdiv.id = value.name.replace(/[ ]/g, "") + "-div";
                        text = document.createElement("p");
                        text.innerHTML = value.name;
                        subdiv.appendChild(text);
                        if (value.type == "string") {
                            input = document.createElement("input");
                            input.value = value.default;
                            subdiv.appendChild(input);
                        }
                        else if (value.type == "check") {
                            input = document.createElement("input");
                            input.type = "checkbox";
                            if (value.default == "true") {
                                input.checked = true;
                            }
                            else {
                                input.checked = false;
                            }
                            subdiv.appendChild(input);
                        }
                        else if (value.type == "spin") {
                            input = document.createElement("input");
                            input.type = "number";
                            input.max = value.max;
                            input.min = value.min;
                            input.value = value.default;
                            input.onchange = function () {
                                if (!/^(\-|\+)?(0|[1-9][0-9]*)$/.test($("#" + value.name.replace(/[ ]/g, "") + "-input").value)) {
                                    $("#" + value.name.replace(/[ ]/g, "") + "-input").value = parseInt(value.default);
                                }
                                else if ($("#" + value.name.replace(/[ ]/g, "") + "-input").value < parseInt(value.min)) {
                                    $("#" + value.name.replace(/[ ]/g, "") + "-input").value = parseInt(value.min);
                                }
                                else if ($("#" + value.name.replace(/[ ]/g, "") + "-input").value > parseInt(value.max)) {
                                    $("#" + value.name.replace(/[ ]/g, "") + "-input").value = parseInt(value.max);
                                }
                            }
                            subdiv.appendChild(input);
                        }
                        else if (value.type == "button") {
                            input = document.createElement("button");
                            input.onclick = function () {
                                if (black_engine_protocol == "UCCI") {
                                    ws.send("POST_MSG|BLACK|setoption " + value.name);
                                }
                                else {
                                    ws.send("POST_MSG|BLACK|setoption name " + value.name);
                                }
                            }
                            btntext = document.createTextNode(value.name);
                            input.appendChild(btntext);
                            subdiv.appendChild(input);
                        }
                        else if (value.type == "combo") {
                            input = document.createElement("select");
                            let option;
                            value.values.forEach((opt) => {
                                option = document.createElement("option");
                                option.text = opt;
                                option.value = opt;
                                input.appendChild(option);
                            });
                            subdiv.appendChild(input);
                            input.childNodes.forEach((combooption, comboindex) => {
                                if (combooption.innerHTML == black_engine_options[index].default) {
                                    input.selectedIndex = comboindex;
                                }
                            });
                        }
                        else {
                            console.warn("Unknown option type: ", value.type);
                        }
                        input.id = value.name.replace(/[ ]/g, "") + "-input";
                        subdiv.style.display = "flex";
                        subdiv.style.marginTop = "10px";
                        popup.appendChild(subdiv);
                    });
                }
                else {
                    console.warn("Unknown color: ", color);
                    return;
                }
                let save = document.createElement("button");
                let savetext = document.createTextNode("Apply Changes");
                save.onclick = function () {
                    let Elem = null;
                    if ($("#colorofsettings").innerHTML == "WHITE") {
                        white_engine_options.forEach((value, index) => {
                            if (value.type == "button") {
                                return;
                            }
                            Elem = $("#" + value.name.replace(/[ ]/g, "") + "-input");
                            if (Elem == null) {
                                return;
                            }
                            if (value.type == "check") {
                                white_engine_options[index].current = Elem.checked.toString();
                                if (value.name == "Ponder" || value.name == "USI_Ponder" || value.name == "UCCI_Ponder") {
                                    if (Elem.checked) {
                                        white_engine_ponder = true;
                                    }
                                    else {
                                        white_engine_ponder = false;
                                    }
                                }
                            }
                            else {
                                white_engine_options[index].current = Elem.value.toString();
                            }
                            if (white_engine_protocol == "UCCI") {
                                ws.send("POST_MSG|WHITE|setoption " + white_engine_options[index].name + " " + white_engine_options[index].current);
                            }
                            else {
                                ws.send("POST_MSG|WHITE|setoption name " + white_engine_options[index].name + " value " + white_engine_options[index].current);
                            }
                        });
                        console.log(white_engine_options);
                    }
                    else if ($("#colorofsettings").innerHTML == "BLACK") {
                        black_engine_options.forEach((value, index) => {
                            if (value.type == "button") {
                                return;
                            }
                            Elem = $("#" + value.name.replace(/[ ]/g, "") + "-input");
                            if (Elem == null) {
                                return;
                            }
                            if (value.type == "check") {
                                black_engine_options[index].current = Elem.checked.toString();
                                if (value.name == "Ponder" || value.name == "USI_Ponder" || value.name == "UCCI_Ponder") {
                                    if (Elem.checked) {
                                        black_engine_ponder = true;
                                    }
                                    else {
                                        black_engine_ponder = false;
                                    }
                                }
                            }
                            else {
                                black_engine_options[index].current = Elem.value.toString();
                            }
                            if (black_engine_protocol == "UCCI") {
                                ws.send("POST_MSG|BLACK|setoption " + black_engine_options[index].name + " " + black_engine_options[index].current);
                            }
                            else {
                                ws.send("POST_MSG|BLACK|setoption name " + black_engine_options[index].name + " value " + black_engine_options[index].current);
                            }
                        });
                        console.log(black_engine_options);
                    }
                };
                save.appendChild(savetext);
                popup.appendChild(save);
                let showcurrent = document.createElement("button");
                let showcurrenttext = document.createTextNode("Show Current Value");
                showcurrent.onclick = function () {
                    let Elem = null;
                    if ($("#colorofsettings").innerHTML == "WHITE") {
                        white_engine_options.forEach((value, index) => {
                            if (value.type == "button") {
                                return;
                            }
                            Elem = $("#" + value.name.replace(/[ ]/g, "") + "-input");
                            if (Elem == null || value.current == null) {
                                return;
                            }
                            if (value.type == "check") {
                                if (white_engine_options[index].current == "true") {
                                    Elem.checked = true;
                                }
                                else {
                                    Elem.checked = false;
                                }
                            }
                            else if (value.type == "spin") {
                                Elem.value = parseInt(white_engine_options[index].current);
                            }
                            else if (value.type == "combo") {
                                Elem.childNodes.forEach((combooption, comboindex) => {
                                    if (combooption.innerHTML == white_engine_options[index].current) {
                                        Elem.selectedIndex = comboindex;
                                    }
                                });
                            }
                            else {
                                Elem.value = white_engine_options[index].current;
                            }
                        });
                        console.log(white_engine_options);
                    }
                    else if ($("#colorofsettings").innerHTML == "BLACK") {
                        black_engine_options.forEach((value, index) => {
                            if (value.type == "button") {
                                return;
                            }
                            Elem = $("#" + value.name.replace(/[ ]/g, "") + "-input");
                            if (Elem == null || value.current == null) {
                                return;
                            }
                            if (value.type == "check") {
                                if (black_engine_options[index].current == "true") {
                                    Elem.checked = true;
                                }
                                else {
                                    Elem.checked = false;
                                }
                            }
                            else if (value.type == "spin") {
                                Elem.value = parseInt(black_engine_options[index].current);
                            }
                            else if (value.type == "combo") {
                                Elem.childNodes.forEach((combooption, comboindex) => {
                                    if (combooption.innerHTML == black_engine_options[index].current) {
                                        Elem.selectedIndex = comboindex;
                                    }
                                });
                            }
                            else {
                                Elem.value = black_engine_options[index].current;
                            }
                        });
                        console.log(black_engine_options);
                    }
                };
                showcurrent.appendChild(showcurrenttext);
                popup.appendChild(showcurrent);
                let reloadoptions = document.createElement("button");
                let reloadoptionstext = document.createTextNode("Reload Engine Options");
                reloadoptions.appendChild(reloadoptionstext);
                reloadoptions.onclick = function () {
                    changing_engine_settings = false;
                    if ($("#colorofsettings").innerHTML == "WHITE") {
                        loading_engine_white = true;
                        white_engine_datastream = "";
                        white_engine_options = [];
                        white_engine_variants = [];
                        if (white_engine_protocol == "UCI" || white_engine_protocol == "UCI_CYCLONE") {
                            postMessageToEngine("WHITE", "uci", true);
                        }
                        else if (white_engine_protocol == "USI") {
                            postMessageToEngine("WHITE", "usi", true);
                        }
                        else if (white_engine_protocol == "UCCI") {
                            postMessageToEngine("WHITE", "ucci", true);
                        }
                    }
                    else if ($("#colorofsettings").innerHTML == "BLACK") {
                        loading_engine_black = true;
                        black_engine_datastream = "";
                        black_engine_options = [];
                        black_engine_variants = [];
                        if (black_engine_protocol == "UCI" || black_engine_protocol == "UCI_CYCLONE") {
                            postMessageToEngine("BLACK", "uci", true);
                        }
                        else if (black_engine_protocol == "USI") {
                            postMessageToEngine("BLACK", "usi", true);
                        }
                        else if (black_engine_protocol == "UCCI") {
                            postMessageToEngine("BLACK", "ucci", true);
                        }
                    }
                    while (document.getElementById("enginesettingspopup") != null) {
                        document.getElementById("enginesettingspopup").remove();
                    }
                }
                popup.appendChild(reloadoptions);
                let postmsg = document.createElement("button");
                let postmsgtext = document.createTextNode("Post Message To Engine");
                postmsg.appendChild(postmsgtext);
                postmsg.onclick = function () {
                    let str = prompt("Enter the command that you want to send to the engine.\nBe aware that do not enter any setoption or other commands that changes the settings of the engine, as it will make the values in the GUI differ from engine's settings and can cause problems.");
                    if (str == null || str == "") {
                        return;
                    }
                    if ($("#colorofsettings").innerHTML == "WHITE") {
                        postMessageToEngine("WHITE", str, true);
                    }
                    else if ($("#colorofsettings").innerHTML == "BLACK") {
                        postMessageToEngine("BLACK", str, true);
                    }
                }
                popup.appendChild(postmsg);
                let cancel = document.createElement("button");
                let canceltext = document.createTextNode("Cancel");
                cancel.appendChild(canceltext);
                cancel.onclick = function () {
                    while (document.getElementById("enginesettingspopup") != null) {
                        document.getElementById("enginesettingspopup").remove();
                    }
                    changing_engine_settings = false;
                };
                popup.appendChild(cancel);
                document.body.appendChild(popup);
                popup.style.display = "block";
            }

            const postMessageToEngine = (color, msg, using) => {
                if (WebSocketStatus == "CONNECTED") {
                    if (color == "WHITE") {
                        if (white_engine != "") {
                            if (using) {
                                ws.send("POST_MSG|WHITE|" + msg);
                            }
                        }
                    }
                    else if (color == "BLACK") {
                        if (black_engine != "") {
                            if (using) {
                                ws.send("POST_MSG|BLACK|" + msg);
                            }
                        }
                    }
                    else {
                        console.warn("Unknown color: ", color);
                    }
                }
            }

            const getVariants = () => {
                stockfish.postMessage(`uci`);
            };

            const newGameCommand = (color) => {
                if (typeof color != "string") {
                    return null;
                }
                if (color == "WHITE") {
                    if (white_engine_protocol == "UCI" || white_engine_protocol == "UCI_CYCLONE") {
                        return "ucinewgame";
                    }
                    else if (white_engine_protocol == "USI") {
                        return "usinewgame";
                    }
                    else if (white_engine_protocol == "UCCI") {
                        return "uccinewgame";
                    }
                }
                else if (color == "BLACK") {
                    if (black_engine_protocol == "UCI" || black_engine_protocol == "UCI_CYCLONE") {
                        return "ucinewgame";
                    }
                    else if (black_engine_protocol == "USI") {
                        return "usinewgame";
                    }
                    else if (black_engine_protocol == "UCCI") {
                        return "uccinewgame";
                    }
                }
                else {
                    return null;
                }
            }

            const setPositionCommand = (color, fen, moves) => {
                if (typeof color != "string" || typeof fen != "string" || typeof moves != "string") {
                    return null;
                }
                if (color == "WHITE") {
                    if (fen.length > 0) {
                        if (white_engine_protocol == "UCI") {
                            return `position fen ${fen} moves ${moves}`;
                        }
                        else if (white_engine_protocol == "USI") {
                            return `position sfen ${ConvertFENtoSFEN(fen)} moves ${convertUCImovestoUSImoves(moves, 9, 9)}`;
                        }
                        else if (white_engine_protocol == "UCCI" || white_engine_protocol == "UCI_CYCLONE") {
                            return `position fen ${fen} moves ${convertUCImovestoUCCImoves(moves, 9, 10)}`;
                        }
                    }
                    else {
                        if (white_engine_protocol == "UCI") {
                            return `position startpos moves ${moves}`;
                        }
                        else if (white_engine_protocol == "USI") {
                            return `position startpos moves ${convertUCImovestoUSImoves(moves, 9, 9)}`;
                        }
                        else if (white_engine_protocol == "UCCI" || white_engine_protocol == "UCI_CYCLONE") {
                            return `position startpos moves ${convertUCImovestoUCCImoves(moves, 9, 10)}`;
                        }
                    }
                }
                else if (color == "BLACK") {
                    if (fen.length > 0) {
                        if (black_engine_protocol == "UCI") {
                            return `position fen ${fen} moves ${moves}`;
                        }
                        else if (black_engine_protocol == "USI") {
                            return `position sfen ${ConvertFENtoSFEN(fen)} moves ${convertUCImovestoUSImoves(moves, 9, 9)}`;
                        }
                        else if (black_engine_protocol == "UCCI" || black_engine_protocol == "UCI_CYCLONE") {
                            return `position fen ${fen} moves ${convertUCImovestoUCCImoves(moves, 9, 10)}`;
                        }
                    }
                    else {
                        if (black_engine_protocol == "UCI") {
                            return `position startpos moves ${moves}`;
                        }
                        else if (black_engine_protocol == "USI") {
                            return `position startpos moves ${convertUCImovestoUSImoves(moves, 9, 9)}`;
                        }
                        else if (black_engine_protocol == "UCCI" || black_engine_protocol == "UCI_CYCLONE") {
                            return `position startpos moves ${convertUCImovestoUCCImoves(moves, 9, 10)}`;
                        }
                    }
                }
                else {
                    return null;
                }
            }

            const setVariant = () => {
                play_move = false;
                force_stop();
                const variant = $("#dropdown-variant").value;
                stockfish.postMessage(`setoption name UCI_Variant value ${variant}`);
                stockfish.postMessage(`position startpos`);
                if (WebSocketStatus == "CONNECTED") {
                    if (white_engine != "") {
                        if (white_engine_variants.includes(variant)) {
                            if (white_engine_has_variants_option) {
                                if (white_engine_protocol == "UCI" || white_engine_protocol == "UCI_CYCLONE") {
                                    postMessageToEngine("WHITE", `setoption name UCI_Variant value ${variant}`, true);
                                }
                                else if (white_engine_protocol == "USI") {
                                    postMessageToEngine("WHITE", `setoption name USI_Variant value ${variant}`, true);
                                }
                                else if (white_engine_protocol == "UCCI") {
                                    postMessageToEngine("WHITE", `setoption UCCI_Variant ${variant}`, true);
                                }
                            }
                            postMessageToEngine("WHITE", newGameCommand("WHITE").toString(), true);
                            using_white_engine = true;
                            $("#whiteunsupportedvariant").hidden = true;
                        }
                        else {
                            console.log("Engine WHITE: " + white_engine_name + " does not support variant " + variant + ". Fairy Stockfish WASM will be used instead.");
                            using_white_engine = false;
                            $("#whiteunsupportedvariant").hidden = false;
                        }
                    }
                    if (black_engine != "") {
                        if (black_engine_variants.includes(variant)) {
                            if (black_engine_has_variants_option) {
                                if (black_engine_protocol == "UCI" || black_engine_protocol == "UCI_CYCLONE") {
                                    postMessageToEngine("BLACK", `setoption name UCI_Variant value ${variant}`, true);
                                }
                                else if (black_engine_protocol == "USI") {
                                    postMessageToEngine("BLACK", `setoption name USI_Variant value ${variant}`, true);
                                }
                                else if (black_engine_protocol == "UCCI") {
                                    postMessageToEngine("BLACK", `setoption UCCI_Variant ${variant}`, true);
                                }
                            }
                            postMessageToEngine("BLACK", newGameCommand("BLACK").toString(), true);
                            using_black_engine = true;
                            $("#blackunsupportedvariant").hidden = true;
                        }
                        else {
                            console.log("Engine BLACK: " + black_engine_name + " does not support variant " + variant + ". Fairy Stockfish WASM will be used instead.");
                            using_black_engine = false;
                            $("#blackunsupportedvariant").hidden = false;
                        }
                    }
                }
                $("#fen").value = "";
                $("#move").value = "";
                resetTimer();
            };

            const setFen = (interrupt_ponder, automatically_start_engine_thinking) => {
                stop(interrupt_ponder);
                const fen = $("#fen").value.trim();
                const moves = $("#move").value.trim();
                const stm = $("#label-stm").innerText;

                if (fen.length > 0) {
                    stockfish.postMessage(`position fen ${fen} moves ${moves}`);
                    
                } else {
                    stockfish.postMessage(`position startpos moves ${moves}`);
                    /*if (interrupt_ponder || !advanced_time_control || (advanced_time_control && !during_play)) {
                        postMessageToEngine("WHITE", `position startpos moves ${moves}`, using_white_engine);
                        postMessageToEngine("BLACK", `position startpos moves ${moves}`, using_black_engine);
                    }
                    else {
                        if (stm == "white") {
                            if (white_engine_ponder) {
                                if (white_engine_ponder_move != "0000" && white_engine_ponder_move != $("#move").value.trim().split(' ').at(-1)) {
                                    white_engine_ponder_miss = true;
                                    postMessageToEngine("WHITE", `stop\nposition startpos moves ${moves}`, using_white_engine);
                                    console.log("WHITE ponder miss");
                                }
                                else if (white_engine_ponder_move == "0000") {
                                    postMessageToEngine("WHITE", `position startpos moves ${moves}`, using_white_engine);
                                }
                            }
                            else {
                                postMessageToEngine("WHITE", `position startpos moves ${moves}`, using_white_engine);
                            }
                            if (black_engine_ponder) {
                                postMessageToEngine("BLACK", `position startpos moves ${moves} ${black_engine_ponder_move}`, using_black_engine);
                            }
                            else {
                                postMessageToEngine("BLACK", `position startpos moves ${moves}`, using_black_engine);
                            }
                        }
                        else if (stm == "black") {
                            if (black_engine_ponder) {
                                if (black_engine_ponder_move != "0000" && black_engine_ponder_move != $("#move").value.trim().split(' ').at(-1)) {
                                    black_engine_ponder_miss = true;
                                    postMessageToEngine("BLACK", `stop\nposition startpos moves ${moves}`, using_black_engine);
                                    console.log("BLACK ponder miss");
                                }
                                else if (black_engine_ponder_move == "0000") {
                                    postMessageToEngine("BLACK", `position startpos moves ${moves}`, using_black_engine);
                                }
                            }
                            else {
                                postMessageToEngine("BLACK", `position startpos moves ${moves}`, using_black_engine);
                            }
                            if (white_engine_ponder) {
                                postMessageToEngine("WHITE", `position startpos moves ${moves} ${white_engine_ponder_move}`, using_white_engine);
                            }
                            else {
                                postMessageToEngine("WHITE", `position startpos moves ${moves}`, using_white_engine);
                            }
                        }
                    }*/
                }
                if (interrupt_ponder || !advanced_time_control || (advanced_time_control && !during_play)) {
                    postMessageToEngine("WHITE", setPositionCommand("WHITE", fen, moves), using_white_engine);
                    postMessageToEngine("BLACK", setPositionCommand("BLACK", fen, moves), using_black_engine);
                }
                else {
                    if (stm == "white") {
                        if (white_engine_ponder) {
                            if (white_engine_ponder_move != "0000" && white_engine_ponder_move != $("#move").value.trim().split(' ').at(-1)) {
                                white_engine_ponder_miss = true;
                                postMessageToEngine("WHITE", `stop\n${setPositionCommand("WHITE", fen, moves) }`, using_white_engine);
                                console.log("WHITE ponder miss");
                            }
                            else if (white_engine_ponder_move == "0000") {
                                postMessageToEngine("WHITE", setPositionCommand("WHITE", fen, moves), using_white_engine);
                            }
                        }
                        else {
                            postMessageToEngine("WHITE", setPositionCommand("WHITE", fen, moves), using_white_engine);
                        }
                        if (black_engine_ponder) {
                            postMessageToEngine("BLACK", setPositionCommand("BLACK", fen, `${moves} ${black_engine_ponder_move}`), using_black_engine);
                        }
                        else {
                            postMessageToEngine("BLACK", setPositionCommand("BLACK", fen, moves), using_black_engine);
                        }
                    }
                    else if (stm == "black") {
                        if (black_engine_ponder) {
                            if (black_engine_ponder_move != "0000" && black_engine_ponder_move != $("#move").value.trim().split(' ').at(-1)) {
                                black_engine_ponder_miss = true;
                                postMessageToEngine("BLACK", `stop\n${setPositionCommand("BLACK", fen, moves) }`, using_black_engine);
                                console.log("BLACK ponder miss");
                            }
                            else if (black_engine_ponder_move == "0000") {
                                postMessageToEngine("BLACK", setPositionCommand("BLACK", fen, moves), using_black_engine);
                            }
                        }
                        else {
                            postMessageToEngine("BLACK", setPositionCommand("BLACK", fen, moves), using_black_engine);
                        }
                        if (white_engine_ponder) {
                            postMessageToEngine("WHITE", setPositionCommand("WHITE", fen, `${moves} ${white_engine_ponder_move}`), using_white_engine);
                        }
                        else {
                            postMessageToEngine("WHITE", setPositionCommand("WHITE", fen, moves), using_white_engine);
                        }
                    }
                }
                
                if (automatically_start_engine_thinking && stm != "undefined" && ((play_white && stm == "white") || (play_black && stm == "black"))) {
                    setTimeout(go(), 10);
                }
            };

            const totalMoveNumber = () => {
                let listlength = 0;
                let i = 0;
                moves_split = $("#move").value.split(' ');
                for (i = 0; i < moves_split.length; i++) {
                    if (moves_split[i].length == 0) {
                        continue;
                    }
                    listlength++;
                }
                return listlength;
            }

            const displayMove = (movenum, is_force_stop) => {
                if ($("#displayready").value.length > 0 && $("#displayready").value > 0)  //$("#displayready").value = 0, displayMove() is ready
                {
                    return;
                }
                $("#displayready").value = 2;  //2 = displayMove() working
                let i = 0;
                let j = 0;
                moves_split = $("#move").value.trim().split(' ');
                if (movenum == -1) {
                    if (is_force_stop) {
                        force_stop();
                    } else {
                        stop(true);
                    }
                    //postMessageToEngine("WHITE", "ucinewgame", using_white_engine);
                    //postMessageToEngine("BLACK", "ucinewgame", using_black_engine);
                    $("#displaymoves").value = $("#move").value.trim();
                    review_mode = false;
                    $("#isreviewmode").value = 0;
                } else if (movenum > totalMoveNumber() || movenum < -1) {
                    console.log(`${movenum} is out of range for move number.`);
                    return;
                } else {
                    if (is_force_stop) {
                        force_stop();
                    } else {
                        stop(true);
                    }
                    //postMessageToEngine("WHITE", "ucinewgame", using_white_engine);
                    //postMessageToEngine("BLACK", "ucinewgame", using_black_engine);
                    review_mode = true;
                    $("#isreviewmode").value = 1;
                    $("#displaymoves").value = "";
                    for (i = 0, j = 0; j < movenum; i++, j++) {
                        if (moves_split[i].length == 0) {
                            j--;
                            continue;
                        }
                        $("#displaymoves").value = $("#displaymoves").value.concat(moves_split[i]);
                        if (j < movenum - 1) {
                            $("#displaymoves").value = $("#displaymoves").value.concat(" ");
                        }
                    }
                }
                const fen = $("#fen").value.trim();
                const display_moves = $("#displaymoves").value.trim();
                if (fen.length > 0) {
                    stockfish.postMessage(`position fen ${fen} moves ${display_moves}`);
                } else {
                    stockfish.postMessage(`position startpos moves ${display_moves}`);
                    //postMessageToEngine("WHITE", `position startpos moves ${display_moves}`, using_white_engine);
                    //postMessageToEngine("BLACK", `position startpos moves ${display_moves}`, using_black_engine);
                }
                postMessageToEngine("WHITE", setPositionCommand("WHITE", fen, display_moves), using_white_engine);
                postMessageToEngine("BLACK", setPositionCommand("BLACK", fen, display_moves), using_black_engine);
                console.log(`${display_moves}`);
                $("#displayready").value = 1;  //1 = updateChessBoardToPosition() working
            };

            const displayNextMove = () => {
                if ($("#gotomovenum").value.length <= 0) {
                    $("#gotomovenum").value = totalMoveNumber();
                } else {
                    if ($("#gotomovenum").value < 0) {
                        $("#gotomovenum").value = 0;
                    } else if ($("#gotomovenum").value >= totalMoveNumber()) {
                        $("#gotomovenum").value = totalMoveNumber();
                    } else {
                        $("#gotomovenum").value++;
                    }
                }
                if ($("#advtimectrl").checked == true) {
                    $("#advtimectrl").click();
                }
                displayMove($("#gotomovenum").value, true);
            }

            const displayPreviousMove = () => {
                if ($("#gotomovenum").value.length <= 0) {
                    $("#gotomovenum").value = totalMoveNumber();
                } else {
                    if ($("#gotomovenum").value <= 0) {
                        $("#gotomovenum").value = 0;
                    } else if ($("#gotomovenum").value > totalMoveNumber()) {
                        $("#gotomovenum").value = totalMoveNumber();
                    } else {
                        $("#gotomovenum").value--;
                    }
                }
                if ($("#advtimectrl").checked == true) {
                    $("#advtimectrl").click();
                }
                displayMove($("#gotomovenum").value, true);
            }

            const displayInitialPosition = () => {
                $("#gotomovenum").value = 0;
                if ($("#advtimectrl").checked == true) {
                    $("#advtimectrl").click();
                }
                displayMove(0, true);
            }

            const displayCurrentPosition = () => {
                $("#gotomovenum").value = totalMoveNumber();
                console.log(`Current: ${!during_play}`);
                displayMove(-1, !during_play);
            }

            const displaySpecifiedPosition = () => {
                if ($("#gotomovenum").value.length <= 0) {
                    $("#gotomovenum").value = totalMoveNumber();
                }
                if ($("#gotomovenum").value < 0) {
                    $("#gotomovenum").value = 0;
                } else if ($("#gotomovenum").value > totalMoveNumber()) {
                    $("#gotomovenum").value = totalMoveNumber();
                }
                if ($("#advtimectrl").checked == true) {
                    $("#advtimectrl").click();
                }
                displayMove($("#gotomovenum").value, true);
            }

            const reset = () => {
                review_mode = false;
                board_setup_mode = false;
                $("#fen").value = "";
                $("#move").value = "";
                white_engine_datastream = "";
                black_engine_datastream = "";
                resetTimer();
                postMessageToEngine("WHITE", `stop\n${newGameCommand("WHITE")}`, using_white_engine);
                postMessageToEngine("BLACK", `stop\n${newGameCommand("BLACK")}`, using_black_engine);
                setFen(true, false);
                $("#currentposition").click();
            };

            const undo = () => {
                if (review_mode || board_setup_mode) {
                    return;
                }
                const moves = $("#move").value;
                $("#move").value = moves.substring(0, moves.lastIndexOf(" "));
                postMessageToEngine("WHITE", "stop", using_white_engine);
                postMessageToEngine("BLACK", "stop", using_black_engine);
                resetTimer();
                setFen(true, false);
            };

            const go = () => {
                if (board_setup_mode || (advanced_time_control && !during_play)) {
                    return;
                }
                return_early = play_move;
                console.log(`return early: ${return_early}`);
                if (return_early) return; // avoid race condition
                stop(false);
                console.log("white ponder: ", white_engine_ponder, " ", white_engine_ponder_move);
                console.log("black ponder: ", black_engine_ponder, " ", black_engine_ponder_move);
                let args = "";
                let wargs = "";
                let bargs = "";
                const movetime = $("#movetime").value;
                const depth = $("#depth").value;
                const nodes = $("#nodes").value;
                const threadnum = $("#threads").value;
                const hashsize = $("#hash").value;
                const multipleprincipalvariation = $("#multipv").value;
                const whitedepth = $("#whitedepth").value;
                const whitemovetime = $("#whitemovetime").value;
                const whitenodes = $("#whitenodes").value;
                const blackdepth = $("#blackdepth").value;
                const blackmovetime = $("#blackmovetime").value;
                const blacknodes = $("#blacknodes").value;
                let wtime = 0;
                let btime = 0;
                let winc = 0;
                let binc = 0;
                if (analysis_mode) {
                    args += " infinite";
                    wargs += " infinite";
                    bargs += " infinite";
                }
                else if (advanced_time_control) {
                    if (white_timer_type == "infinite" && $("#label-stm").innerHTML == "white") {
                        args += "infinite";
                        wargs += "infinite";
                        console.log("wtime infinite");
                    }
                    else if (black_timer_type == "infinite" && $("#label-stm").innerHTML == "black") {
                        args += "infinite";
                        bargs += "infinite";
                        console.log("btime infinite");
                    }
                    else {
                        if (white_timer_type == "time per move") {
                            wtime += (+white_moving_time_list[0]);
                            winc += (+white_moving_time_list[0]);
                        }
                        else if (white_timer_type == "tournament") {
                            wtime += (+((+white_remaining_time) + (+white_time_gain)));
                            winc += (+white_time_gain);
                        }
                        else if (white_timer_type == "hourglass") {  //How to tell that it's hourglass to engine?
                            wtime += (+white_remaining_time);
                        }
                        else if (white_timer_type == "byoyomi") {
                            wtime += (+white_remaining_time);
                        }
                        if (black_timer_type == "time per move") {
                            btime += (+black_moving_time_list[0]);
                            binc += (+black_moving_time_list[0]);
                        }
                        else if (black_timer_type == "tournament") {
                            btime += (+((+black_remaining_time) + (+black_time_gain)));
                            binc = (+black_time_gain);
                        }
                        else if (black_timer_type == "hourglass") {  //How to tell that it's hourglass to engine?
                            btime += (+black_remaining_time);
                        }
                        else if (black_timer_type == "byoyomi") {
                            btime += (+black_remaining_time);
                        }
                        console.log(`wtime ${wtime} winc ${winc} btime ${btime} binc ${binc}`);
                        args += ` wtime ${wtime} winc ${winc} btime ${btime} binc ${binc}`;
                        if (white_engine_protocol == "UCCI") {
                            wargs += ` time ${wtime} increment ${winc} opptime ${btime} oppincrement ${binc}`;
                        }
                        else {
                            wargs += ` wtime ${wtime} winc ${winc} btime ${btime} binc ${binc}`;
                        }
                        if (black_engine_protocol == "UCCI") {
                            bargs += ` time ${btime} increment ${binc} opptime ${wtime} oppincrement ${winc}`;
                        }
                        else {
                            bargs += ` wtime ${wtime} winc ${winc} btime ${btime} binc ${binc}`;
                        }
                        stockfish.postMessage(`setoption name Move Overhead value ${timer_interval}`);
                    }
                }
                else {
                    if (!analysis_mode && $("#depth").validity.valid && depth.length > 0) {
                        args += ` depth ${depth}`;
                    }
                    if (!analysis_mode && $("#movetime").validity.valid && movetime.length > 0) {
                        args += ` movetime ${movetime}`;
                    }
                    if (!analysis_mode && $("#nodes").validity.valid && nodes.length > 0) {
                        args += ` nodes ${nodes}`;
                    }
                    if ($("#whitedepth").validity.valid && whitedepth.length > 0) {
                        wargs += ` depth ${whitedepth}`;
                    }
                    if ($("#whitemovetime").validity.valid && whitemovetime.length > 0) {
                        wargs += ` movetime ${whitemovetime}`;
                    }
                    if ($("#whitenodes").validity.valid && whitenodes.length > 0) {
                        wargs += ` nodes ${whitenodes}`;
                    }
                    if ($("#blackdepth").validity.valid && blackdepth.length > 0) {
                        bargs += ` depth ${blackdepth}`;
                    }
                    if ($("#blackmovetime").validity.valid && blackmovetime.length > 0) {
                        bargs += ` movetime ${blackmovetime}`;
                    }
                    if ($("#blacknodes").validity.valid && blacknodes.length > 0) {
                        bargs += ` nodes ${blacknodes}`;
                    }
                }
                console.log("args:", args, "\nwargs:", wargs, "\nbargs:", bargs);

                if (threadnum.length <= 0 || threadnum < 1) {
                    stockfish.postMessage(`setoption name Threads value 1`);
                }
                else if (threadnum > 512) {
                    stockfish.postMessage(`setoption name Threads value 512`);
                }
                else {
                    stockfish.postMessage(`setoption name Threads value ${threadnum}`);
                }
                //stockfish.postMessage(`setoption name clear hash`);
                if (hashsize.length <= 0 || hashsize < 1) {
                    stockfish.postMessage(`setoption name Hash value 16`);
                }
                else if (hashsize > 33554432) {
                    stockfish.postMessage(`setoption name Hash value 33554432`);
                }
                else {
                    stockfish.postMessage(`setoption name Hash value ${hashsize}`);
                }
                if (multipleprincipalvariation.length <= 0 || multipleprincipalvariation < 1) {
                    stockfish.postMessage(`setoption name MultiPV value 1`);
                }
                else if (multipleprincipalvariation > 500) {
                    stockfish.postMessage(`setoption name Hash value 500`);
                }
                else {
                    stockfish.postMessage(`setoption name MultiPV value ${multipleprincipalvariation}`);
                }

                const stm = $("#label-stm").innerText;
                play_move = (play_white && stm == "white") || (play_black && stm == "black");
                if (stm == "white" && WebSocketStatus == "CONNECTED") {
                    if (white_engine != "" && using_white_engine) {
                        if (advanced_time_control && white_engine_ponder && white_engine_ponder_move == $("#move").value.trim().split(' ').at(-1)) {
                            postMessageToEngine("WHITE", "ponderhit", true);
                            console.log("WHITE ponder hit");
                        }
                        else {
                            postMessageToEngine("WHITE", `go${wargs}`, true);
                            console.log("WHITE: go " + wargs);
                        }
                    }
                    else {
                        stockfish.postMessage(`go${args}`);
                    }
                    if (advanced_time_control && white_timer_type != "infinite" && black_engine_ponder && black_engine_ponder_move != "0000") {
                        postMessageToEngine("BLACK", `go ponder${bargs}`, using_black_engine);
                    }
                }
                else if (stm == "black" && WebSocketStatus == "CONNECTED") {
                    if (black_engine != "" && using_black_engine) {
                        if (advanced_time_control && black_engine_ponder && black_engine_ponder_move == $("#move").value.trim().split(' ').at(-1)) {
                            postMessageToEngine("BLACK", "ponderhit", true);
                            console.log("BLACK ponder hit");
                        }
                        else {
                            postMessageToEngine("BLACK", `go${bargs}`, true);
                            console.log("BLACK: go " + bargs);
                        }
                    }
                    else {
                        stockfish.postMessage(`go${args}`);
                    }
                    if (advanced_time_control && black_timer_type != "infinite" && white_engine_ponder && white_engine_ponder_move != "0000") {
                        postMessageToEngine("WHITE", `go ponder${wargs}`, using_white_engine);
                    }
                }
                else {
                    stockfish.postMessage(`go${args}`);
                }
                output2 = "";
                $("#output2").innerText = output2;
                scrollOutput();
            };

            const setupTimer = () => {
                $("#timeoutside").value = 0;
                white_timer_type = $("#dropdown-whitetimemode").value;
                black_timer_type = $("#dropdown-blacktimemode").value;
                white_remaining_time = parseInt($("#whitestarttime").value);
                black_remaining_time = parseInt($("#blackstarttime").value);
                if (isNaN(white_remaining_time) || white_remaining_time.length < 1 || white_remaining_time < 1) {
                    white_remaining_time = 600000;
                }
                if (isNaN(black_remaining_time) || black_remaining_time.length < 1 || black_remaining_time < 1) {
                    black_remaining_time = 600000;
                }
                white_time_gain = parseInt($("#whitetimegain").value);
                black_time_gain = parseInt($("#blacktimegain").value);
                if (isNaN(white_time_gain) || white_time_gain.length < 1 || white_time_gain < 0) {
                    white_time_gain = 0;
                }
                if (isNaN(black_time_gain) || black_time_gain.length < 1 || black_time_gain < 0) {
                    black_time_gain = 0;
                }
                white_byoyomi_time_per_period = parseInt($("#whitebyoyomitime").value);
                black_byoyomi_time_per_period = parseInt($("#blackbyoyomitime").value);
                if (isNaN(white_byoyomi_time_per_period) || white_byoyomi_time_per_period.length < 1 || white_byoyomi_time_per_period < 1) {
                    white_byoyomi_time_per_period = 30000;
                }
                if (isNaN(black_byoyomi_time_per_period) || black_byoyomi_time_per_period.length < 1 || black_byoyomi_time_per_period < 1) {
                    black_byoyomi_time_per_period = 30000;
                }
                white_byoyomi_period_count = parseInt($("#whitebyoyomiperiodcount").value);
                black_byoyomi_period_count = parseInt($("#blackbyoyomiperiodcount").value);
                if (isNaN(white_byoyomi_period_count) || white_byoyomi_period_count.length < 1 || white_byoyomi_period_count < 1) {
                    white_byoyomi_period_count = 1;
                }
                if (isNaN(black_byoyomi_period_count) || black_byoyomi_period_count.length < 1 || black_byoyomi_period_count < 1) {
                    black_byoyomi_period_count = 1;
                }
                white_remaining_byoyomi_periods = white_byoyomi_period_count;
                black_remaining_byoyomi_periods = black_byoyomi_period_count;
                white_time_margin = parseInt($("#whitetimemargin").value);
                black_time_margin = parseInt($("#blacktimemargin").value);
                if (isNaN(white_time_margin) || white_time_margin.length < 1 || white_time_margin < 0) {
                    white_time_margin = 0;
                }
                if (isNaN(black_time_margin) || black_time_margin.length < 1 || black_time_margin < 0) {
                    black_time_margin = 0;
                }
                white_moving_time_list = [];
                black_moving_time_list = [];
                white_moving_time_list.push(white_remaining_time);  //Start time white
                black_moving_time_list.push(black_remaining_time);  //Start time black
                $("#whitetime").innerHTML = `${parseInt(white_remaining_time / 1000)}`;
                $("#blacktime").innerHTML = `${parseInt(black_remaining_time / 1000)}`;
                if (white_timer_type == "infinite") {
                    $("#whitetime").innerHTML = "INFINITY";
                }
                if (black_timer_type == "infinite") {
                    $("#blacktime").innerHTML = "INFINITY";
                }
                previous_mover = "";
            }

            const resetTimer = () => {
                $("#whitetime").innerHTML = "--";
                $("#blacktime").innerHTML = "--";
                previous_mover = "";
                $("#timeoutside").value = 0;
            }

            function updateTimer() {
                if ($("#gamestatus").innerHTML == "END") {
                    deleteTimer();
                    gameEnd();
                    return;
                }
                $("#gamestatus").click();
                console.log(`${$("#gamestatus").innerHTML}`);
                if ($("#gamestatus").innerHTML == "PLAYING_WHITE") {
                    if (previous_mover == "") {
                        if (white_timer_type == "tournament") {
                            white_remaining_time = (+white_remaining_time) + (+white_time_gain) + (+timer_interval);
                        }
                        white_moving_time_list.push(white_remaining_time);  //Time stamp for white's turn begin
                    }
                    else if (previous_mover == "BLACK") {
                        black_moving_time_list.push(black_remaining_time);  //Time stamp for black's turn end
                        if (black_remaining_time < 0) {
                            black_remaining_time = 0;
                        }
                        if (white_timer_type == "tournament") {
                            white_remaining_time = (+white_remaining_time) + (+white_time_gain) + (+timer_interval);
                        }
                        else if (white_timer_type == "time per move") {
                            white_remaining_time = (+white_moving_time_list[0]) + (+timer_interval);
                        }
                        else if (white_timer_type == "byoyomi") {
                            if (white_remaining_byoyomi_periods < white_byoyomi_period_count) {
                                white_remaining_time = (+white_byoyomi_time_per_period) + (+timer_interval);
                            }
                            else {
                                white_remaining_time = (+white_remaining_time) + (+timer_interval);
                            }
                        }
                        if (black_timer_type == "hourglass") {
                            white_remaining_time = (+white_remaining_time) + (+black_moving_time_list.at(-2)) - (+black_moving_time_list.at(-1)) + (+timer_interval);
                        }
                        white_moving_time_list.push(white_remaining_time);  //Time stamp for white's turn begin
                    }
                    if (white_timer_type == "infinite") {
                        previous_mover = "WHITE";
                        return;
                    }
                    white_remaining_time = white_remaining_time - timer_interval;
                    if (white_timer_type == "byoyomi" && white_remaining_time <= 0) {
                        if (white_remaining_byoyomi_periods == 0) {
                            ;
                        }
                        else {
                            white_remaining_byoyomi_periods--;
                            white_remaining_time = (+white_byoyomi_time_per_period);
                            console.log("WHITE byoyomi remaining periods: " + white_remaining_byoyomi_periods);
                        }
                    }
                    if (white_remaining_time < -white_time_margin) {
                        deleteTimer();
                        $("#timeoutside").value = 1;
                        timeIsUpFor("WHITE");
                        return;
                    }
                    if (white_timer_type == "infinite") {
                        $("#whitetime").innerHTML = "INFINITY";
                    }
                    else if (white_remaining_time >= 10000) {
                        $("#whitetime").innerHTML = `${parseInt(white_remaining_time / 1000)}`;
                    }
                    else {
                        $("#whitetime").innerHTML = `${parseInt(white_remaining_time / 100) / 10}`;
                    }
                    if (black_timer_type == "infinite") {
                        $("#blacktime").innerHTML = "INFINITY";
                    }
                    else if (black_remaining_time >= 10000) {
                        $("#blacktime").innerHTML = `${parseInt(black_remaining_time / 1000)}`;
                    }
                    else {
                        $("#blacktime").innerHTML = `${parseInt(black_remaining_time / 100) / 10}`;
                    }
                    previous_mover = "WHITE";
                }
                else if ($("#gamestatus").innerHTML == "PLAYING_BLACK") {
                    if (previous_mover == "") {
                        if (black_timer_type == "tournament") {
                            black_remaining_time = (+black_remaining_time) + (+black_time_gain) + (+timer_interval);
                        }
                        black_moving_time_list.push(black_remaining_time);  //Time stamp for black's turn begin
                    }
                    else if (previous_mover == "WHITE") {
                        white_moving_time_list.push(white_remaining_time);  //Time stamp for white's turn end
                        if (white_remaining_time < 0) {
                            white_remaining_time = 0;
                        }
                        if (black_timer_type == "tournament") {
                            black_remaining_time = (+black_remaining_time) + (+black_time_gain) + (+timer_interval);
                        }
                        else if (black_timer_type == "time per move") {
                            black_remaining_time = (+black_moving_time_list[0]) + (+timer_interval);
                        }
                        else if (black_timer_type == "byoyomi") {
                            if (black_remaining_byoyomi_periods < black_byoyomi_period_count) {
                                black_remaining_time = (+black_byoyomi_time_per_period) + (+timer_interval);
                            }
                            else {
                                black_remaining_time = (+black_remaining_time) + (+timer_interval);
                            }
                        }
                        if (white_timer_type == "hourglass") {
                            black_remaining_time = (+black_remaining_time) + (+white_moving_time_list.at(-2)) - (+white_moving_time_list.at(-1)) + (+timer_interval);
                        }
                        black_moving_time_list.push(black_remaining_time);  //Time stamp for black's turn begin
                    }
                    if (black_timer_type == "infinite") {
                        previous_mover = "BLACK";
                        return;
                    }
                    black_remaining_time = black_remaining_time - timer_interval;
                    if (black_timer_type == "byoyomi" && black_remaining_time <= 0) {
                        if (black_remaining_byoyomi_periods == 0) {
                            ;
                        }
                        else {
                            black_remaining_byoyomi_periods--;
                            black_remaining_time = (+black_byoyomi_time_per_period);
                            console.log("BLACK byoyomi remaining periods: " + black_remaining_byoyomi_periods);
                        }
                    }
                    if (black_remaining_time < -black_time_margin) {
                        deleteTimer();
                        $("#timeoutside").value = 2;
                        timeIsUpFor("BLACK");
                        return;
                    }
                    if (white_timer_type == "infinite") {
                        $("#whitetime").innerHTML = "INFINITY";
                    }
                    else if (white_remaining_time >= 10000) {
                        $("#whitetime").innerHTML = `${parseInt(white_remaining_time / 1000)}`;
                    }
                    else {
                        $("#whitetime").innerHTML = `${parseInt(white_remaining_time / 100) / 10}`;
                    }
                    if (black_timer_type == "infinite") {
                        $("#blacktime").innerHTML = "INFINITY";
                    }
                    else if (black_remaining_time >= 10000) {
                        $("#blacktime").innerHTML = `${parseInt(black_remaining_time / 1000)}`;
                    }
                    else {
                        $("#blacktime").innerHTML = `${parseInt(black_remaining_time / 100) / 10}`;
                    }
                    previous_mover = "BLACK";
                }
            }

            const createTimer = () => {
                timer = setInterval(() => {
                    updateTimer();
                }, timer_interval);
                console.log(`${timer}`);
            }

            const deleteTimer = () => {
                console.log("Timer delete!");
                clearInterval(timer);
            }

            const timeIsUpFor = (side) => {
                force_stop();
                if (side == "WHITE") {
                    white_remaining_time = 0;
                    $("#timeoutside").value = 1;
                    $("#whitetime").innerHTML = "Out Of Time";
                }
                else if (side == "BLACK") {
                    black_remaining_time = 0;
                    $("#timeoutside").value = 2;
                    $("#blacktime").innerHTML = "Out Of Time";
                }
                $("#gamestatus").click();
                gameEnd();
            }

            const gameEnd = () => {
                during_play = false;
                //advanced_time_control = false;
                force_stop();
                $("#currentposition").click();
                $("#input").style.display = "";
                $("#input2").style.display = "";
                $("#posvariantdiv").style.display = "";
            }

            const gameAbort = () => {
                deleteTimer();
                $("#gamestatus").innerHTML = "END";
                gameEnd();
            }

            const goWithTimeControl = () => {
                if ($("#gamestatus").innerHTML != "END") {
                    return;
                }
                //We need to prevent user from doing unnecessary actions during countdown, so we'll hide these divs
                $("#input").style.display = "none";  //These divs are unable to be hidden by {hidden: during_play}
                $("#input2").style.display = "none";
                $("#posvariantdiv").style.display = "none";
                //$("#movecontrol").style.display = "none";
                resetTimer();
                setupTimer();
                $("#gamestatus").click();
                during_play = true;
                $("#currentposition").click();
                white_engine_ponder_move = "0000";
                black_engine_ponder_move = "0000";
                white_engine_ponder_miss = false;
                black_engine_ponder_miss = false;
                createTimer();
                const stm = $("#label-stm").innerText;
                console.log(`white: ${play_white} black: ${play_black} move: ${(play_white && stm == "white") || (play_black && stm == "black")}`);
                if ((play_white && stm == "white") || (play_black && stm == "black")) {
                    console.log("Go!");
                    go();
                }
            }

            const stop = (interrupt_pondering) => {
                stockfish.postMessage(`stop`);
                if (interrupt_pondering || !advanced_time_control) {
                    white_engine_ponder_move = "0000";
                    black_engine_ponder_move = "0000";
                    white_engine_ponder_miss = false;
                    black_engine_ponder_miss = false;
                    postMessageToEngine("WHITE", "stop", using_white_engine);
                    postMessageToEngine("BLACK", "stop", using_black_engine);
                }
                else {
                    if (!white_engine_ponder) {
                        postMessageToEngine("WHITE", "stop", using_white_engine);
                        white_engine_ponder_miss = false;
                    }
                    if (!black_engine_ponder) {
                        postMessageToEngine("BLACK", "stop", using_white_engine);
                        black_engine_ponder_miss = false;
                    }
                }
            };

            const force_stop = () => {
                play_white = play_black = false;
                play_move = false;
                white_engine_datastream = "";
                black_engine_datastream = "";
                stop(true);
            };

            const changePieces = (onlyChangeWhenInvalid) => {
                let index = 0;
                let themename = "";
                let classes = [];
                let DOMListValue = "";
                const el = $("#chessground-container-div");
                index = themes[0].indexOf($("#dropdown-variant").value);
                if (index < 0 || $("#dropdown-variant").value == "") {
                    index = themes[0].indexOf("");
                }
                if (index < 0) {
                    themename = "default";
                }
                else {
                    classes = themes[1][index];
                    if (classes.length < 1) {
                        classes = themes[1][themes[0].indexOf("")];
                    }
                }
                DOMListValue = el.classList.value.split(' ');
                if (classes.length > 0) {
                    index = classes.indexOf(DOMListValue[1]) + 1;
                    if (onlyChangeWhenInvalid) {
                        if (index != 0) {
                            console.log("No need to change piece.");
                            return;
                        }
                    }
                    if (index >= classes.length) {
                        index = 0;
                    }
                    themename = classes[index];
                }
                else {
                    themename = "default";
                }
                DOMListValue[1] = themename;
                el.classList.value = DOMListValue.join(' ');
                console.log(`Piece theme: ${themename}`);
                //const activeIndex = classes.findIndex((c) => el.classList.contains(c));
                //const nextIndex = (activeIndex + 1) % classes.length;
                //el.classList.replace(classes[activeIndex], classes[nextIndex]);
            };

            const changeBoard = (onlyChangeWhenInvalid) => {
                let index = 0;
                let boardthemename = "";
                let classes = [];
                let DOMListValue = "";
                const el = $("#chessground-container-div");
                index = themes[0].indexOf($("#dropdown-variant").value);
                if (index < 0 || $("#dropdown-variant").value == "") {
                    index = themes[0].indexOf("");
                }
                if (index < 0) {
                    boardthemename = "defaultboard";
                }
                else {
                    classes = themes[2][index];
                    if (classes.length < 1) {
                        classes = themes[2][themes[0].indexOf("")];
                    }
                }
                DOMListValue = el.classList.value.split(' ');
                if (classes.length > 0) {
                    index = classes.indexOf(DOMListValue[0]) + 1;
                    if (onlyChangeWhenInvalid) {
                        if (index != 0) {
                            console.log("No need to change board.");
                            return;
                        }
                    }
                    if (index >= classes.length) {
                        index = 0;
                    }
                    boardthemename = classes[index];
                }
                else {
                    boardthemename = "defaultboard";
                }
                DOMListValue[0] = boardthemename;
                el.classList.value = DOMListValue.join(' ');
                console.log(`Board theme: ${boardthemename}`);
                //const activeIndex = classes.findIndex((c) => el.classList.contains(c));
                //const nextIndex = (activeIndex + 1) % classes.length;
                //el.classList.replace(classes[activeIndex], classes[nextIndex]);
            };

            const scrollOutput = () => {
                $("#output2-div").scrollTo({
                    top: $("#output2-div").scrollHeight,
                    behavior: "smooth",
                });
            };

            const displayGameResult = () => {
                let i = 0;
                let chi = document.getElementsByTagName("spangameresult");
                for (i = 0; i < chi.length; i++) {
                    document.body.removeChild(chi[i]);
                }
                if (review_mode) {
                    return;
                }
                var span = document.createElement("spangameresult");
                span.innerHTML = $("#gameresult").value;
                span.style.left = (window.innerWidth / 2) + "px";
                span.style.top = (window.innerHeight / 2) + "px";
                setTimeout(function () {
                    span.style.opacity = "1";
                    span.style.transform = "scale(40)";
                }, 100);
                setTimeout(function () {
                    span.style.opacity = "0";
                    span.style.transform = "scale(0.02)";
                }, 2600);
                document.body.appendChild(span);
            }

            // Make error catchable
            const loadStockfish = async (params) => {
                return await Stockfish(params);
            };

            const onFinishDownload = (data) => {
                if (!data) {
                    stockfish_state = "FAILED";
                    m.redraw();
                    return;
                }

                loadStockfish({ wasmBinary: data })
                    .then((_stockfish) => {
                        stockfish = _stockfish;
                        stockfish_state = "READY";
                        stockfish.addMessageListener((line) => {
                            if (line.startsWith("option")) {
                                if (line.startsWith("option name UCI_Variant")) {
                                    variants = line
                                        .replace(
                                            "option name UCI_Variant type combo default chess var ",
                                            ""
                                        )
                                        .replace(/ var /g, " ")
                                        .split(" ");
                                }
                            } else if (line.startsWith(" ")) {
                            } else {
                                if (!review_mode && line.startsWith("bestmove") && play_move) {
                                    play_move = false;
                                    $("#move").value += " " + line.split(" ")[1];
                                    $("#set").click();
                                }
                                output2 += line + "\n";
                                $("#output2").innerText = output2;
                                scrollOutput();
                            }
                            m.redraw();
                        });
                        getVariants();
                    })
                    .catch((e) => {
                        stockfish_state = "FAILED";
                        throw e;
                    })
                    .finally(() => m.redraw());
            };

            const onSelectNnueFile = async (e) => {
                const selected = e.currentTarget.files[0];
                if (selected) {
                    //
                    // TODO:
                    // On Archlinux Chromium 92.0.4515.107, most of times this code fails with the error saying:
                    //   TypeError: Failed to execute 'decode' on 'TextDecoder': The provided ArrayBufferView value must not be shared.
                    // On the other hand, either Chrome with the same version or Firefox never fail.
                    //
                    const FS = stockfish.FS;
                    const buffer = await selected.arrayBuffer();
                    const array = new Uint8Array(buffer);
                    const filename = "/" + selected.name;
                    FS.writeFile(filename, array);
                    stockfish.postMessage(`setoption name EvalFile value ${filename}`);
                    // Automatically set variant
                    const variant = selected.name.split(/[_.-]+/)[0];
                    $("#dropdown-variant").value = variant;
                    $("#dropdown-variant").dispatchEvent(new Event("change"));
                }
            };

            const onSelectVariantsFile = async (e) => {
                const selected = e.currentTarget.files[0];
                //console.log(`${selected}`);
                if (selected) {
                    const FS = stockfish.FS;
                    const buffer = await selected.arrayBuffer();
                    const array = new Uint8Array(buffer);
                    const filename = "/" + selected.name;
                    FS.writeFile(filename, array);
                    stockfish.postMessage(`check ${filename}`);
                    stockfish.postMessage(`load ${filename}`);
                    getVariants();
                }
            };

            const oninit = () => {
                stockfish_state = "LOADING";
            };

            const view = () => {
                const is_ready = stockfish_state == "READY";

                return m("main", [
                    m("p#pagetitle", "Advanced"),
                    m("div#misc", [
                        m("div", [
                            `Fairy-Stockfish WASM: ${stockfish_state} - download: `,
                            m(RequestProgress, {
                                url: "./lib/stockfish.wasm",
                                onFinishDownload,
                            }),
                        ]),
                        m("div", [
                            `WebSocket Server Backend Connection Status: ${WebSocketStatus} `,
                            m(
                                "span",
                                {
                                    style: "cursor: pointer;",
                                    onclick: () =>
                                        window.alert(
                                            "Due to browser security restrictions, binary executables can be only executed on server side by using a backend. FairyGround uses Node.js as the backend."
                                        ),
                                },
                                "[?]"
                            ),
                        ]),
                        m("div", { hidden: during_play }, [
                            "- nnue file: ",
                            m("input", {
                                type: "file",
                                disabled: !is_ready,
                                onchange: onSelectNnueFile,
                            }),
                            m(
                                "span",
                                {
                                    style: "cursor: pointer;",
                                    onclick: () =>
                                        window.alert(
                                            "You can upload a Fairy-Stockfish compatible .nnue file. Downloads: https://fairy-stockfish.github.io/nnue/#current-best-nnue-networks."
                                        ),
                                },
                                "[?]"
                            ),
                        ]),
                        m("div", { hidden: during_play }, [
                            "- variants.ini: ",
                            m("input#variants-ini", {
                                type: "file",
                                disabled: !is_ready || review_mode || board_setup_mode,
                                onchange: onSelectVariantsFile,
                            }),
                            m(
                                "span",
                                {
                                    style: "cursor: pointer;",
                                    onclick: () =>
                                        window.alert(
                                            "You can upload a Fairy-Stockfish compatible variants.ini file. See here for details: https://github.com/ianfab/Fairy-Stockfish/wiki/Variant-configuration. Uploading variants file here will not change the settings of binary engines you loaded."
                                        ),
                                },
                                "[?]"
                            ),
                        ]),
                        m("div", { hidden: during_play }, [
                            "- positionvariants.txt: ",
                            m("input#posvariant-txt", {
                                type: "file",
                                disabled: !is_ready || review_mode || board_setup_mode,
                            }),
                            m(
                                "span",
                                {
                                    style: "cursor: pointer;",
                                    onclick: () =>
                                        window.alert(
                                            "You can select a Position Variant file to load different positions for different variants. Contents will be appended to the position variants provided by the server."
                                        ),
                                },
                                "[?]"
                            ),
                        ]),
                    ]),
                    m("div#input", { hidden: during_play }, [
                        m(
                            "select#dropdown-variant",
                            {
                                disabled: !is_ready || review_mode || board_setup_mode,
                                onchange: (e) => {
                                    window.setTimeout(setVariant, 10);
                                },
                            },
                            [
                                m("option", { value: "" }, "-- VARIANT --"),
                                ...variants.map((ex, index) => m("option", { value: ex }, ex)),
                            ]
                        ),
                        m("input#fen", {
                            placeholder: "Input FEN Here",
                            disabled: !is_ready || review_mode,
                            onkeyup: (e) => {
                                if (e.keyCode != 13) {
                                    e.redraw = false;
                                    return;
                                }
                                setFen(true, false);
                            },
                        }),
                        m("input#move", {
                            placeholder: "Input Move Here",
                            disabled: !is_ready || review_mode,
                            onkeyup: (e) => {
                                if (e.keyCode != 13) {
                                    e.redraw = false;
                                    return;
                                }
                                setFen(true, false);
                            },
                        }),
                        m(
                            "button#setpos",
                            {
                                disabled: !is_ready || review_mode,
                                onclick: () => {
                                    if (review_mode) {
                                        return;
                                    }
                                    resetTimer();
                                    postMessageToEngine("WHITE", newGameCommand("WHITE"), using_white_engine);
                                    postMessageToEngine("BLACK", newGameCommand("BLACK"), using_black_engine);
                                    white_engine_datastream = "";
                                    black_engine_datastream = "";
                                    window.setTimeout(() => {
                                        setFen(true, false);
                                    }, 10);
                                    $("#currentposition").click();
                                },
                            },
                            "Set"
                        ),
                        m("button#reset", { disabled: !is_ready, onclick: reset }, "Reset"),
                        m("button#undo", { disabled: !is_ready || review_mode || board_setup_mode, hidden: review_mode, onclick: undo }, "Undo"),
                    ]),
                    m("div#posvariantdiv", [
                        m("p", "Position Variant Type:"),
                        m(
                            "select#dropdown-posvarianttype",
                            {
                                disabled: !is_ready || review_mode,
                            },
                            [
                                m("option", { value: "(default)" }, "(default)"),
                            ]
                        ),
                        m("p", "Position Variant Name:"),
                        m(
                            "select#dropdown-posvariantname",
                            {
                                disabled: !is_ready || review_mode,
                                onchange: () => {
                                    postMessageToEngine("WHITE", newGameCommand("WHITE"), using_white_engine);
                                    postMessageToEngine("BLACK", newGameCommand("BLACK"), using_black_engine);
                                },
                            },
                            []
                        ),
                        m("button#aboutposition", {
                            disabled: !is_ready || review_mode,
                        }, "About this position"),
                    ]),
                    m("div#enginesettings", { hidden: during_play }, [
                        m("p", "Load binary engines: (White refers to first mover and black refers to second mover)"),
                        m("p", "If there are spaces in the path, please add quotes to enclose the path.(e.g. \"D:\\e n g i n e.exe\")"),
                        m("div#whiteengine", [
                            m("input#whiteenginepath", {
                                placeholder: "White engine path on server (e.g. D:\\engine.exe)",
                                disabled: !is_ready || review_mode || board_setup_mode || WebSocketStatus != "CONNECTED",
                            }),
                            m("select#whiteengineprotocol", {
                                disabled: !is_ready || review_mode,
                            },
                                [
                                    m("option", { value: "UCI" }, "UCI"),
                                    m("option", { value: "USI" }, "USI"),
                                    m("option", { value: "UCCI" }, "UCCI"),
                                    m("option", { value: "UCI_CYCLONE" }, "UCI-Cyclone"),
                                ]),
                            m("button#whiteenginesettings", {
                                disabled: !is_ready,
                                onclick: () => {
                                    if (board_setup_mode) {
                                        return;
                                    }
                                    if (WebSocketStatus == "CLOSED") {
                                        window.alert("You are disconnected from the WebSocket server. Loading binary engines are not available unless you reload the page.");
                                        return;
                                    }
                                    if (WebSocketStatus == "ERROR" || ws == null) {
                                        window.alert("Cannot establish connection to the WebSocket Server. If you are running locally, check whether the server is running properly and the port is accessible. If you are running WebSocket Server on the remote server, ask the server administrators about it.");
                                        return;
                                    }
                                    if (white_engine == "") {
                                        window.alert("Engine is not loaded.");
                                        return;
                                    }
                                    changing_engine_settings = true;
                                    EditEngineSettings("WHITE", ws);
                                },
                            }, "Engine Settings"),
                            m("button#whitesupportedvariants", {
                                disabled: !is_ready,
                                onclick: () => {
                                    if (board_setup_mode) {
                                        return;
                                    }
                                    if (WebSocketStatus == "CLOSED") {
                                        window.alert("You are disconnected from the WebSocket server. Loading binary engines are not available unless you reload the page.");
                                        return;
                                    }
                                    if (WebSocketStatus == "ERROR" || ws == null) {
                                        window.alert("Cannot establish connection to the WebSocket Server. If you are running locally, check whether the server is running properly and the port is accessible. If you are running WebSocket Server on the remote server, ask the server administrators about it.");
                                        return;
                                    }
                                    if (white_engine == "") {
                                        window.alert("Engine is not loaded.");
                                        return;
                                    }
                                    window.alert(white_engine_name + "\n\nSupport Variants:\n" + white_engine_variants);
                                },
                            }, "Supported Variants"),
                            m("input[type=number]#whitedepth", {
                                placeholder: "Depth",
                                disabled: !is_ready || WebSocketStatus != "CONNECTED" || analysis_mode,
                                min: 1,
                            }),
                            m("input[type=number]#whitemovetime", {
                                placeholder: "Movetime",
                                disabled: !is_ready || WebSocketStatus != "CONNECTED" || analysis_mode,
                                min: 0,
                            }),
                            m("input[type=number]#whitenodes", {
                                placeholder: "Nodes",
                                disabled: !is_ready || WebSocketStatus != "CONNECTED" || analysis_mode,
                                min: 1,
                            }),
                            m("p#whiteunsupportedvariant", { hidden: true }, "This engine does not support this variant. Fairy Stockfish WASM will be used instead."),
                        ]),
                        m("div#blackengine", [
                            m("input#blackenginepath", {
                                placeholder: "Black engine path on server (e.g. D:\\engine.exe)",
                                disabled: !is_ready || review_mode || board_setup_mode || WebSocketStatus != "CONNECTED",
                            }),
                            m("select#blackengineprotocol", {
                                disabled: !is_ready || review_mode,
                            },
                                [
                                    m("option", { value: "UCI" }, "UCI"),
                                    m("option", { value: "USI" }, "USI"),
                                    m("option", { value: "UCCI" }, "UCCI"),
                                    m("option", { value: "UCI_CYCLONE" }, "UCI-Cyclone"),
                                ]),
                            m("button#blackenginesettings", {
                                disabled: !is_ready,
                                onclick: () => {
                                    if (board_setup_mode) {
                                        return;
                                    }
                                    if (WebSocketStatus == "CLOSED") {
                                        window.alert("You are disconnected from the WebSocket server. Loading binary engines are not available unless you reload the page.");
                                        return;
                                    }
                                    if (WebSocketStatus == "ERROR" || ws == null) {
                                        window.alert("Cannot establish connection to the WebSocket Server. If you are running locally, check whether the server is running properly and the port is accessible. If you are running WebSocket Server on the remote server, ask the server administrators about it.");
                                        return;
                                    }
                                    if (black_engine == "") {
                                        window.alert("Engine is not loaded.");
                                        return;
                                    }
                                    changing_engine_settings = true;
                                    EditEngineSettings("BLACK", ws);
                                },
                            }, "Engine Settings"),
                            m("button#blacksupportedvariants", {
                                disabled: !is_ready,
                                onclick: () => {
                                    if (board_setup_mode) {
                                        return;
                                    }
                                    if (WebSocketStatus == "CLOSED") {
                                        window.alert("You are disconnected from the WebSocket server. Loading binary engines are not available unless you reload the page.");
                                        return;
                                    }
                                    if (WebSocketStatus == "ERROR" || ws == null) {
                                        window.alert("Cannot establish connection to the WebSocket Server. If you are running locally, check whether the server is running properly and the port is accessible. If you are running WebSocket Server on the remote server, ask the server administrators about it.");
                                        return;
                                    }
                                    if (black_engine == "") {
                                        window.alert("Engine is not loaded.");
                                        return;
                                    }
                                    window.alert(black_engine_name + "\n\nSupport Variants:\n" + black_engine_variants);
                                },
                            }, "Supported Variants"),
                            m("input[type=number]#blackdepth", {
                                placeholder: "Depth",
                                disabled: !is_ready || WebSocketStatus != "CONNECTED" || analysis_mode,
                                min: 1,
                            }),
                            m("input[type=number]#blackmovetime", {
                                placeholder: "Movetime",
                                disabled: !is_ready || WebSocketStatus != "CONNECTED" || analysis_mode,
                                min: 0,
                            }),
                            m("input[type=number]#blacknodes", {
                                placeholder: "Nodes",
                                disabled: !is_ready || WebSocketStatus != "CONNECTED" || analysis_mode,
                                min: 1,
                            }),
                            m("p#blackunsupportedvariant", { hidden: true }, "This engine does not support this variant. Fairy Stockfish WASM will be used instead."),
                        ]),
                        m("div#enginecontrol", [
                            m(
                                "button#loadengines",
                                {
                                    disabled: !is_ready || review_mode,
                                    onclick: () => {
                                        if (board_setup_mode) {
                                            return;
                                        }
                                        if (loading_engine_white || loading_engine_black) {
                                            console.warn("Loading engine.");
                                            return;
                                        }
                                        if (WebSocketStatus == "CLOSED") {
                                            window.alert("You are disconnected from the WebSocket server. Loading binary engines are not available unless you reload the page.");
                                            return;
                                        }
                                        if (WebSocketStatus == "ERROR" || ws == null) {
                                            window.alert("Cannot establish connection to the WebSocket Server. If you are running locally, check whether the server is running properly and the port is accessible. If you are running WebSocket Server on the remote server, ask the server administrators about it.");
                                            return;
                                        }
                                        //$("#reset").click();
                                        if ($("#whiteenginepath").value != "") {
                                            loading_engine_white = true;
                                            white_engine_protocol = $("#whiteengineprotocol").value;
                                            white_engine_options = [];
                                            white_engine_datastream = "";
                                            white_engine_variants = [];
                                            white_engine_ponder = false;
                                            white_engine_ponder_miss = false;
                                        }
                                        else {
                                            white_engine = "";
                                            console.log("White engine has been set to Fairy Stockfish WASM");
                                        }
                                        if ($("#blackenginepath").value != "") {
                                            loading_engine_black = true;
                                            black_engine_protocol = $("#blackengineprotocol").value;
                                            black_engine_options = [];
                                            black_engine_datastream = "";
                                            black_engine_variants = [];
                                            black_engine_ponder = false;
                                            black_engine_ponder_miss = false;
                                        }
                                        else {
                                            black_engine = "";
                                            console.log("Black engine has been set to Fairy Stockfish WASM");
                                        }
                                        ws.send("LOAD_ENGINE|" + $("#whiteenginepath").value + "|" + $("#blackenginepath").value + "|" + $("#whiteengineprotocol").value + "|" + $("#blackengineprotocol").value);
                                        setTimeout(() => {
                                            if (loading_engine_white) {
                                                white_engine = "";
                                                console.error("Load engine timed out for white.");
                                                window.alert("Load engine timed out for white.");
                                                loading_engine_white = false;
                                                white_engine = "";
                                                white_engine_variants = [];
                                            }
                                            if (loading_engine_black) {
                                                black_engine = "";
                                                console.error("Load engine timed out for black.");
                                                window.alert("Load engine timed out for black.");
                                                loading_engine_black = false;
                                                black_engine = "";
                                                black_engine_variants = [];
                                            }
                                        }, load_engine_timeout);
                                    },
                                },
                                "Load"
                            ),
                        ]),
                    ]),
                    m("div#ffishsettings-outdiv", { hidden: during_play }, [
                        m("div#ffishsettings", { hidden: during_play }, [
                            m("p", "Fairy Stockfish WASM settings: "),
                            m("input[type=number]#depth", {
                                placeholder: "Depth",
                                disabled: !is_ready || analysis_mode,
                                min: 1,
                                max: 255,
                            }),
                            m("input[type=number]#movetime", {
                                placeholder: "Movetime",
                                disabled: !is_ready || analysis_mode,
                                min: 0,
                            }),
                            m("input[type=number]#nodes", {
                                placeholder: "Nodes",
                                disabled: !is_ready || analysis_mode,
                                min: 1,
                            }),
                            m("input[type=number]#threads", {
                                placeholder: "Threads",
                                disabled: !is_ready,
                                min: 1,
                                max: 512,
                            }),
                            m("input[type=number]#hash", {
                                placeholder: "Hash",
                                disabled: !is_ready,
                                min: 1,
                                max: 33554432,
                            }),
                            m("input[type=number]#multipv", {
                                placeholder: "MultiPV",
                                disabled: !is_ready,
                                min: 1,
                                max: 500,
                            }),
                        ]),
                    ]),
                    m("div#input2", { hidden: during_play }, [
                        m("button#go", {
                            disabled: !is_ready, onclick: () => {
                                if ($("#advtimectrl").checked == true) {
                                    $("#advtimectrl").click();
                                }
                                white_engine_datastream = "";
                                black_engine_datastream = "";
                                setTimeout(() => {
                                    if (!review_mode) {
                                        setFen(true, false);
                                    }
                                    go();
                                }, 10);
                            }
                        }, "Go"),
                        m(
                            "button#stop",
                            { disabled: !is_ready, onclick: force_stop },
                            "Stop"
                        ),
                        m(
                            "label#label-analysis",
                            m("input[type=checkbox]#analysis", {
                                checked: analysis_mode,
                                disabled: play_white || play_black || advanced_time_control || board_setup_mode,
                                onclick: () => {
                                    analysis_mode = !analysis_mode;
                                },
                            }),
                            "Analysis"
                        ),
                        m(
                            "label",
                            m("input[type=checkbox]#playwhite", {
                                checked: play_white,
                                disabled: analysis_mode || review_mode || board_setup_mode,
                                onclick: () => {
                                    play_white = !play_white;
                                },
                            }),
                            "Engine white"
                        ),
                        m(
                            "label",
                            m("input[type=checkbox]#playblack", {
                                checked: play_black,
                                disabled: analysis_mode || review_mode || board_setup_mode,
                                onclick: () => {
                                    play_black = !play_black;
                                },
                            }),
                            "Engine black"
                        ),
                        m(
                            "label#label-advtimectrl",
                            m("input[type=checkbox]#advtimectrl", {
                                checked: advanced_time_control,
                                disabled: analysis_mode || review_mode || board_setup_mode,
                                onclick: () => {
                                    advanced_time_control = !advanced_time_control;
                                },
                            }),
                            "Advanced Time Control"
                        ),
                        m(
                            "label#label-boardsetup",
                            m("input[type=checkbox]#isboardsetup", {
                                checked: board_setup_mode,
                                disabled: analysis_mode || review_mode || advanced_time_control,
                                onclick: () => {
                                    board_setup_mode = !board_setup_mode;
                                },
                                onchange: () => {
                                    if ($("#isboardsetup").checked == false) {
                                        postMessageToEngine("WHITE", newGameCommand("WHITE"), using_white_engine);
                                        postMessageToEngine("BLACK", newGameCommand("BLACK"), using_black_engine);
                                    }
                                },
                            }),
                            "Board Setup"
                        ),
                        m("p#label-stm", { hidden: true }),
                        m("input#displaymoves", {
                            placeholder: "Moves displayed on board for analysis",
                            hidden: true,
                        }),
                        m("input[type=number]#displayready", {
                            placeholder: "Board display update ready status",
                            hidden: true,
                        }),
                        m("input[type=number]#isreviewmode", {
                            placeholder: "Stores value to judge whether it is in review mode",
                            hidden: true,
                        }),
                        m("input#gameresult", {
                            placeholder: "The game result",
                            hidden: true,
                            onclick: () => {
                                displayGameResult();
                            },
                        }),
                        m("p#gamestatus", {
                            hidden: true,
                        }, "END"),
                        m("input[type=number]#timeoutside", {
                            placeholder: "Stores value that the side that run out of time",
                            hidden: true,
                        }),
                        m("p#set", {
                            onclick: () => {
                                if (review_mode) {
                                    return;
                                }
                                window.setTimeout(() => {
                                    setFen(false, true);
                                }, 10);
                            },
                            hidden: true,
                        }, "Set position (internal)"),
                        m("p#loadthemes", {
                            hidden: true,
                            onclick: () => {
                                LoadThemes();
                            }
                        }, "Load Themes (internal)"),
                        m("p#initializethemes", {
                            hidden: true,
                            onclick: () => {
                                changePieces(true);
                                changeBoard(true);
                            }
                        }, "Initialize Themes (internal)"),
                        m("p#copysetfen", {
                            hidden: true,
                            onclick: () => {
                                copyText($("#fen").value);
                            }
                        }, "Copy Set FEN (internal)"),
                    ]),
                    m("div#advancedtimesettings", { hidden: !advanced_time_control || during_play }, [
                        m("div#whitetimesettings", [
                            m("p", "White Time Settings:  "),
                            m(
                                "select#dropdown-whitetimemode",
                                {
                                    disabled: !is_ready || review_mode,
                                    onchange: () => {
                                        $("#whitetimetype").innerHTML = $("#dropdown-whitetimemode").value;
                                        //white_timer_type = $("#dropdown-whitetimemode").value;
                                    },
                                },
                                [
                                    m("option", { value: "infinite" }, "Infinite"),
                                    m("option", { value: "tournament" }, "Tournament"),
                                    m("option", { value: "time per move" }, "Time Per Move"),
                                    m("option", { value: "hourglass" }, "Hourglass"),
                                    m("option", { value: "byoyomi" }, "Byo-yomi"),
                                ]
                            ),
                            m("input[type=number]#whitestarttime", {
                                placeholder: "Start time (ms)",
                                disabled: !is_ready || review_mode || $("#whitetimetype").innerHTML == "infinite",
                                min: 1,
                            }),
                            m("input[type=number]#whitetimegain", {
                                placeholder: "Time gain (ms)",
                                disabled: !is_ready || review_mode || $("#whitetimetype").innerHTML != "tournament",
                                min: 0,
                            }),
                            m("input[type=number]#whitebyoyomitime", {
                                placeholder: "Byoyomi time per period (ms)",
                                disabled: !is_ready || review_mode || $("#whitetimetype").innerHTML != "byoyomi",
                                min: 1,
                            }),
                            m("input[type=number]#whitebyoyomiperiodcount", {
                                placeholder: "Byoyomi period count",
                                disabled: !is_ready || review_mode || $("#whitetimetype").innerHTML != "byoyomi",
                                min: 1,
                            }),
                            m("input[type=number]#whitetimemargin", {
                                placeholder: "Time margin (ms)",
                                disabled: !is_ready || review_mode || $("#whitetimetype").innerHTML == "infinite",
                                min: 0,
                            }),
                        ]),
                        m("div#blacktimesettings", [
                            m("p", "Black Time Settings:  "),
                            m(
                                "select#dropdown-blacktimemode",
                                {
                                    disabled: !is_ready || review_mode,
                                    onchange: () => {
                                        $("#blacktimetype").innerHTML = $("#dropdown-blacktimemode").value;
                                        //black_timer_type = $("#dropdown-blacktimemode").value;
                                    },
                                },
                                [
                                    m("option", { value: "infinite" }, "Infinite"),
                                    m("option", { value: "tournament" }, "Tournament"),
                                    m("option", { value: "time per move" }, "Time Per Move"),
                                    m("option", { value: "hourglass" }, "Hourglass"),
                                    m("option", { value: "byoyomi" }, "Byo-yomi"),
                                ]
                            ),
                            m("input[type=number]#blackstarttime", {
                                placeholder: "Start time (ms)",
                                disabled: !is_ready || review_mode || $("#blacktimetype").innerHTML == "infinite",
                                min: 1,
                            }),
                            m("input[type=number]#blacktimegain", {
                                placeholder: "Time gain (ms)",
                                disabled: !is_ready || review_mode || $("#blacktimetype").innerHTML != "tournament",
                                min: 0,
                            }),
                            m("input[type=number]#blackbyoyomitime", {
                                placeholder: "Byoyomi time per period (ms)",
                                disabled: !is_ready || review_mode || $("#blacktimetype").innerHTML != "byoyomi",
                                min: 1,
                            }),
                            m("input[type=number]#blackbyoyomiperiodcount", {
                                placeholder: "Byoyomi period count",
                                disabled: !is_ready || review_mode || $("#blacktimetype").innerHTML != "byoyomi",
                                min: 1,
                            }),
                            m("input[type=number]#blacktimemargin", {
                                placeholder: "Time margin (ms)",
                                disabled: !is_ready || review_mode || $("#blacktimetype").innerHTML == "infinite",
                                min: 0,
                            }),
                        ]),
                        m("div#gamecontrol-start", [
                            m("button#gamestart", { disabled: !is_ready || review_mode, onclick: goWithTimeControl }, "Start Game"),
                            m("p", {
                                onclick: () => {
                                    alert("This time control system allows user select different time modes for two sides and gives user more choice on time odds settings.\nThe time modes are:\nInfinite: Selected side has infinite time.\nTournament: Selected side has limited time and may get a time increment after a move.\nTime per move: Selected side need to make each move within a fixed time limit.\nHourglass: Selected side has limited time and used time will be added to opponent's time.\nByo-yomi: Selected side will enter the countdown(byoyomi) period(s) after their initial time runs out. During countdown periods, if the player make a move before the countdown period time runs out, the time will be reset to full time of countdown periods(Specified in \"byoyomi time per period\"), otherwise the remaining period count will be decreased by 1 and the time will be reset to full time of countdown periods(Specified in \"byoyomi time per period\"). If there's no countdown periods left and the remaining time runs out, this side runs out of time.\nNote: if you set engine's time mode to infinite, it will think forever!");
                                }
                            }, "[Why can I choose different time modes for two sides?]"),
                            m("p", {
                                onclick: () => {
                                    alert("Start time: The initial time at the beginning of the game. Not applicable to infinite.\nTime gain: Get a time increment of this many milliseconds after every move. Only applicable to tournament.\nByoyomi time per period: The time (in milliseconds) of each period when in extra countdown(byoyomi) periods. Only applicable to byo-yomi.\nByoyomi period count: The count of countdown(byoyomi) periods. Only applicable to byo-yomi.\nTime margin: The time can be exceeded by this many milliseconds. The remaining time will be shown as minus numbers if exceeded. Not applicable to infinite.");
                                }
                            }, "  [What are these parameters?]"),
                        ]),
                    ]),
                    m("div#gamesettings", [
                        m("p", {}, "Quick promote/demote to piece: "),
                        m(
                            "select#dropdown-quickpromotion",
                            {
                                disabled: !is_ready || review_mode || board_setup_mode,
                            },
                            [
                                m("option", { value: "" }, "<DISABLED>"),
                                m("option", { value: "a" }, "a"),
                                m("option", { value: "b" }, "b"),
                                m("option", { value: "c" }, "c"),
                                m("option", { value: "d" }, "d"),
                                m("option", { value: "e" }, "e"),
                                m("option", { value: "f" }, "f"),
                                m("option", { value: "g" }, "g"),
                                m("option", { value: "h" }, "h"),
                                m("option", { value: "i" }, "i"),
                                m("option", { value: "j" }, "j"),
                                m("option", { value: "k" }, "k"),
                                m("option", { value: "l" }, "l"),
                                m("option", { value: "m" }, "m"),
                                m("option", { value: "n" }, "n"),
                                m("option", { value: "o" }, "o"),
                                m("option", { value: "p" }, "p"),
                                m("option", { value: "q" }, "q"),
                                m("option", { value: "r" }, "r"),
                                m("option", { value: "s" }, "s"),
                                m("option", { value: "t" }, "t"),
                                m("option", { value: "u" }, "u"),
                                m("option", { value: "v" }, "v"),
                                m("option", { value: "w" }, "w"),
                                m("option", { value: "x" }, "x"),
                                m("option", { value: "y" }, "y"),
                                m("option", { value: "z" }, "z"),
                                m("option", { value: "+" }, "Promote (+)"),
                                m("option", { value: "-" }, "Demote (-)"),
                                m("option", { value: "=" }, "Keep (=)"),
                            ]
                        ),
                        m(
                            "label",
                            m("input[type=checkbox]#clickclickmove", { disabled: review_mode }),
                            "Click-click move"
                        ),
                    ]),
                    m("div#boardsetupsettings", { hidden: !board_setup_mode }, [
                        m("p", "Board Setup:"),
                        m("div#boardpiecechange", { disabled: !is_ready }, [
                            m("select#dropdown-setpiece", [
                                m("option", { value: "<move>" }, "<move>"),
                                m("option", { value: "<delete>" }, "<delete>"),
                                m("option", { value: "b" }, "b"),
                                m("option", { value: "k" }, "k"),
                                m("option", { value: "n" }, "n"),
                                m("option", { value: "p" }, "p"),
                                m("option", { value: "q" }, "q"),
                                m("option", { value: "r" }, "r"),
                                m("option", { value: "B" }, "B"),
                                m("option", { value: "K" }, "K"),
                                m("option", { value: "N" }, "N"),
                                m("option", { value: "P" }, "P"),
                                m("option", { value: "Q" }, "Q"),
                                m("option", { value: "R" }, "R"),
                            ]),
                            m(
                                "button#addtopocket",
                                { disabled: !is_ready },
                                "Add piece to pocket"
                            ),
                            m(
                                "button#clearboard",
                                { disabled: !is_ready },
                                "Clear Board"
                            ),
                            m(
                                "button#initboardpos",
                                { disabled: !is_ready },
                                "Reset Board"
                            ),
                            m(
                                "button#validatepos",
                                { disabled: !is_ready },
                                "Validate Position"
                            ),
                            m(
                                "button#boardsetupcopyfen",
                                { disabled: !is_ready },
                                "Copy FEN & Set"
                            ),
                        ]),
                        m("div#pocketpiecechange", { hidden: true }, [
                            m("form#pieceinpocket", { disabled: !is_ready }, [
                                m("table#tablepieceinpocket", [
                                    m("tr", [
                                        m("td", "Piece ID"),
                                        m("td", "Amount"),
                                    ]),
                                ]),
                            ]),
                        ]),
                    ]),
                    m("div#outputs", [
                        m("div", [
                            m("div#chessground-container-div.defaultboard.default.board8x8", [
                                m("div.cg-wrap.pocket-top", [m("div#pocket-top")]),
                                m("div#chessground-board"),
                                m("div.cg-wrap.pocket-bottom", [m("div#pocket-bottom")]),
                            ]),
                            m("div#boardsetupsettings2", { hidden: !board_setup_mode }, [
                                m("div", [
                                    m("p","Side to move:"),
                                    m("select#dropdown-sidetomove", [
                                        m("option", { value: "First Mover" }, "First Mover"),
                                        m("option", { value: "Second Mover" }, "Second Mover"),
                                    ]),
                                ]),
                                m("div", [
                                    m(
                                        "label",
                                        m("input[type=checkbox]#whitekingsidecastle"),
                                        "White O-O"
                                    ),
                                    m(
                                        "label",
                                        m("input[type=checkbox]#whitequeensidecastle"),
                                        "White O-O-O"
                                    ),
                                    m(
                                        "label",
                                        m("input[type=checkbox]#blackkingsidecastle"),
                                        "Black O-O"
                                    ),
                                    m(
                                        "label",
                                        m("input[type=checkbox]#blackqueensidecastle"),
                                        "Black O-O-O"
                                    ),
                                ]),
                                m("div", [
                                    m("input[type=number]#halfmoveclock", {
                                        placeholder: "Half move clock",
                                        min: 0,
                                    }),
                                    m("input[type=number]#whiteremainingchecks", {
                                        placeholder: "White remaining checks",
                                        min: 0,
                                    }),
                                    m("input[type=number]#blackremainingchecks", {
                                        placeholder: "Black remaining checks",
                                        min: 0,
                                    }),
                                    m("input[type=number]#currentmovenum", {
                                        placeholder: "Current move number",
                                        min: 1,
                                    }),
                                ]),
                                m("div", [
                                    m("input[type=number]#enpassantfile", {
                                        placeholder: "En passant file number",
                                        min: 1,
                                    }),
                                    m("input[type=number]#enpassantrank", {
                                        placeholder: "En passant rank number",
                                        min: 1,
                                    }),
                                ]),
                                m("div", [
                                    m("input#seirwangatingfiles", {
                                        placeholder: "Seirawan gating files (e.g. ABab)",
                                    }),
                                ]),
                            ]),
                            m("div#movecontrol", { hidden: during_play }, [
                                m("button#initialposition", { onclick: displayInitialPosition, disabled: !is_ready }, "Initial Position"),
                                m("button#currentposition", { onclick: displayCurrentPosition, disabled: !is_ready }, "Current Position"),
                                m("button#previousposition", { onclick: displayPreviousMove, disabled: !is_ready }, "Previous Position"),
                                m("button#nextposition", { onclick: displayNextMove, disabled: !is_ready }, "Next Position"),
                                m("input[type=number]#gotomovenum", {
                                    placeholder: "Half Move Number",
                                    disabled: !is_ready,
                                    min: 0,
                                }),
                                m("button#specifiedposition", { onclick: displaySpecifiedPosition, disabled: !is_ready }, "Go to Move"),
                            ]),
                            m("p", { hidden: !review_mode }, "Review mode enabled."),
                            m("p", { hidden: !review_mode }, "You can go to previous moves played to analyze your game, but you cannot make changes to the game. To exit review mode, click <reset> or <current position>."),
                            m("div#controls", [
                                m("div", [
                                    m("button", {
                                        onclick: () => {
                                            changePieces(false);
                                        }
                                    }, "Change pieces"),
                                    m("button", {
                                        onclick: () => {
                                            changeBoard(false);
                                        }
                                    }, "Change board"),
                                    m("button#button-flip", "Flip Board"),
                                ]),
                                m("div", [
                                    m(
                                        "input[type=range]#range-volume",
                                        { min: 0, max: 1, step: 0.05 },
                                        "range"
                                    ),
                                    m(
                                        "label",
                                        m("input[type=checkbox]#check-dests", {
                                            checked: show_dests,
                                            onclick: () => {
                                                show_dests = !show_dests;
                                            },
                                        }),
                                        "Show Legal Moves"
                                    ),
                                    m(
                                        "label",
                                        m("input[type=checkbox]#check-adjudicate", {
                                            checked: adjudicate,
                                            onclick: () => {
                                                adjudicate = !adjudicate;
                                            },
                                        }),
                                        "Adjudicate"
                                    ),
                                ]),
                            ]),
                            m("div#links", [
                                m("a[href='./index.html']", "play"),
                                m("a[href='./advanced.html']", "advanced"),
                                m("a[href='https://github.com/ianfab/fairyground']", "github"),
                            ]),
                        ]),
                        m("div#info", [
                            m("p#positioninfo", ""),
                            m("p#currentboardfen"),
                            m("p#label-pgn"),
                            m("div#output2-div", m("pre#output2", "")),
                            m("div#timers", { hidden: !advanced_time_control }, [
                                m("div#whitetimer", [
                                    m("p", "White Time"),
                                    m("p#whitetime", "--"),
                                    m("p#whitetimetype", "infinite"),
                                ]),
                                m("div#blacktimer", [
                                    m("p", "Black Time"),
                                    m("p#blacktime", "--"),
                                    m("p#blacktimetype", "infinite"),
                                ]),
                            ]),
                            m("div#timecontrolduringplay", { hidden: !advanced_time_control || !during_play }, [
                                m("button#addtimeforwhite", {
                                    onclick: () => {
                                        white_remaining_time = (+white_remaining_time) + 10000;
                                    },
                                }, "Add 10s for white"),
                                m("button#addtimeforblack", {
                                    onclick: () => {
                                        black_remaining_time = (+black_remaining_time) + 10000;
                                    },
                                }, "Add 10s for black"),
                                m("button#gameabort", {
                                    onclick: () => {
                                        if (confirm("Are you sure to abort the game?")) {
                                            gameAbort();
                                        }
                                    },
                                }, "ABORT GAME"),
                            ]),
                        ]),
                    ]),
                ]);
            };

            return { oninit, view };
        };

        if (!isSupported()) {
            window.alert(
                "Your browser is not supported. For more information, please take a look at https://github.com/hi-ogawa/Stockfish/wiki."
            );
        } else {
            m.mount($("#root"), App);
        }
    </script>
</body>
